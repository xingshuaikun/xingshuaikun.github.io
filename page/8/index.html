<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>iHui</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="iHui">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="iHui">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="iHui">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="iHui" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">iHui</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-CUMTOJ算法实验三" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%B8%89/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T16:40:56.000Z" itemprop="datePublished">2019-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%B8%89/">CUMTOJ算法实验三</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="问题-A-评分系统"><a href="#问题-A-评分系统" class="headerlink" title="问题 A: 评分系统"></a>问题 A: 评分系统</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>英语俱乐部举办了一个叫做“英文金曲大赛”的节目。这个节目有好多人参加，这不，成绩出来了，渊子当是很勇敢，自告奋勇接下了算出大家的总得分的任务。当时有7个评委，每个评委都要给选手打分，现在要求去掉一个最高分和去掉一个最低分，再算出平均分。结果精确到小数点后两位。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>测试数据包括多个实例。每组数据包括7个实数，代表评委们对该选手的评分。紧接着是选手的名字，名字的长度不超过30个字符。输入直到文件结束。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出每位选手名字和最终得分，结果保留两位有效数字。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10 10 10 10 10 10 9 xiaoyuanwang<br>0 0 0 0 0 0 0 beast</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>xiaoyuanwang 10.00<br>beast 0.00</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用一个数组arr存储输入的7个分数，string类型的变量name存储姓名，然后处理输出即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 7;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	double arr[max_num] = &#123; 0 &#125;, sum;</span><br><span class="line">	string name;</span><br><span class="line">	while(~scanf(&quot;%lf&quot;,&amp;arr[0]))</span><br><span class="line">	&#123;</span><br><span class="line">		sum = 0;</span><br><span class="line">		int i;</span><br><span class="line">		for(i = 1; i &lt; max_num; i++)</span><br><span class="line">			cin &gt;&gt; arr[i];</span><br><span class="line">		cin &gt;&gt; name;</span><br><span class="line">		sort(arr, arr + max_num);</span><br><span class="line">		for(i = 1; i &lt; max_num - 1; i++)</span><br><span class="line">			sum += arr[i];</span><br><span class="line">		sum = sum / 5;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-B-节食的限制"><a href="#问题-B-节食的限制" class="headerlink" title="问题 B: 节食的限制"></a>问题 B: 节食的限制</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Bessie像她的诸多姊妹一样，因為从Farmer John的草地吃了太多美味的草而长出了太多的赘肉。所以FJ将她置於一个及其严格的节食计划之中。她每天不能吃多过H(5&lt;&#x3D;H&lt;&#x3D;45000)公斤的乾草。Bessie只能吃一整綑乾草；当她开始吃一綑乾草的之后就再也停不下来了。她有一个完整的N(1&lt;&#x3D;n&lt;&#x3D;50)綑可以给她当作晚餐的乾草的清单。她自然想要尽量吃到更多的乾草。很自然地，每綑乾草只能被吃一次（即使在列表中相同的重量可能出现2次，但是这表示的是两綑乾草，其中每綑乾草最多只能被吃掉一次）。 给定一个列表表示每綑乾草的重量Si(1&lt;&#x3D;Si&lt;&#x3D;H),求Bessie不超过节食的限制的前提下可以吃掉多少乾草（注意一旦她开始吃一綑乾草就会把那一綑乾草全部吃完）。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>第一行：两个由空格隔开的整数：H和N， 第2到N+1行：第i+1行是一个单独的整数，表示第i綑乾草的重量Si。</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>一个单独的整数表示Bessie在限制范围内最多可以吃多少公斤的乾草。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>56 4<br>15<br>19<br>20<br>21</p>
</blockquote>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>56</p>
</blockquote>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>典型的0-1背包题，不同的是重量和价值是一样的。</p>
<p>递归函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+w[i]);</span><br></pre></td></tr></table></figure>

<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[55][45002];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int max(int i, int j);</span><br><span class="line">	int min(int i, int j);</span><br><span class="line">    int h, n, i, j, w[55];</span><br><span class="line">    cin &gt;&gt; h &gt;&gt; n;</span><br><span class="line">    for(i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 0; i &lt;= h; i++)</span><br><span class="line">        dp[0][i] = 0;</span><br><span class="line">    for(i = 1; i &lt;= n; i++)</span><br><span class="line">        dp[i][0] = 0;</span><br><span class="line">    for(i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int jMax = min(h, w[i]);</span><br><span class="line">        for(j = 1; j &lt; jMax; j++)</span><br><span class="line">            dp[i][j] = dp[i - 1][j];</span><br><span class="line">        for(j = w[i]; j &lt;= h; j++)</span><br><span class="line">            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][h] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int max(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">	return i &gt; j ? i : j;</span><br><span class="line">&#125;</span><br><span class="line">int min(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">	return i &gt; j ? j : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-C-汽车费用"><a href="#问题-C-汽车费用" class="headerlink" title="问题 C: 汽车费用"></a>问题 C: 汽车费用</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个特别的单行街道在每公里处有一个汽车站。顾客根据他们乘坐汽车的公里使来付费。例如下表就是一个费用的单子。没有一辆车子行驶超过10公里，一个顾客打算行驶n公里(1&lt;&#x3D;n&lt;100)，它可以通过无限次的换车来完成旅程。最后要求费用最少。</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>第一行十个整数分别表示行走1到10公里的费用(&lt;&#x3D;500)。注意这些数并无实际的经济意义，即行驶10公里费用可能比行驶一公里少。第二行一个整数n表示，旅客的总路程数。</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>仅一个整数表示最少费用。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>12 21 31 40 49 58 69 79 90 101<br>15</p>
</blockquote>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>147</p>
</blockquote>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>dp，有最优子结构性质。</p>
<p>完全背包问题。把距离看成背包，先求出1km的最小价格，再求出2km的最小价格……<br>直到求出n km的最小价值。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 100000;</span><br><span class="line">int dp[105];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int min(int i, int j);</span><br><span class="line">    int n, i, j;</span><br><span class="line">    for(i = 1; i &lt;= 10; i++)</span><br><span class="line">        cin &gt;&gt; dp[i];</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(i = 11; i &lt;= n; i++)</span><br><span class="line">        dp[i] = inf;</span><br><span class="line">    for(i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 1; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = min(dp[i], dp[j] + dp[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int min(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">	return i &gt; j ? j : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-D-法师康的工人"><a href="#问题-D-法师康的工人" class="headerlink" title="问题 D: 法师康的工人"></a>问题 D: 法师康的工人</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>三个法师康的工人每天早上6点到工厂开始到三条产品生产线上组装桔子手机。第一个工人在200时刻开始（从6点开始计时，以秒作为单位）在生产线上开始生产，一直到1000时刻。第二个工人，在700时刻开始，在1100时刻结束。第三个工人从1500时刻工作到2100时刻。期间最长至少有一个工人在生产线上工作的连续时间为900秒（从200时刻到1100时刻），而最长的无人生产的连续时间（从生产开始到生产结束）为400时刻（1100时刻到1500时刻）。</p>
<p>你的任务是用一个程序衡量N个工人在N条产品线上的工作时间列表（1≤N≤5000，以秒为单位）。</p>
<p>·最长的至少有一个工人在工作的时间段</p>
<p>·最长的无人工作的时间段（从有人工作开始计）</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入第1行为一个整数N，第2-N+1行每行包括两个均小于1000000的非负整数数据，表示其中一个工人的生产开始时间与结束时间。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>输出为一行，用空格分隔开两个我们所求的数。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>3<br>200 1000<br>700 1100<br>1500 2100</p>
</blockquote>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>900 400</p>
</blockquote>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>result1指最长的至少被一条线段覆盖的连续区间长度。</p>
<p>result2值最长的没被线段覆盖的区间长度。</p>
<p>输入后，先按开始时间从小到大排序。</p>
<p>可以把多个连续的区间（相交或相切）看成一个区间，如何实现呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[j].r = max(arr[i].r,arr[j].r);</span><br></pre></td></tr></table></figure>

<p>arr[j]为上一个连续区间。这时候如果连续区间&gt;result1那么更新下result1。</p>
<p>这样遇到不连续的且断裂的长度&gt;result2就更新下resullt2，再把当前区间赋给j（成为上一个区间）。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 5005;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int l, r;</span><br><span class="line">    bool operator &lt; (const node&amp; c) const</span><br><span class="line">    &#123;</span><br><span class="line">        return l &lt; c.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; arr[max_num];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int max(int i, int j);</span><br><span class="line">    int n, result1, result2;</span><br><span class="line">	int i, j = 0;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i].l;</span><br><span class="line">		cin &gt;&gt; arr[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr, arr + n);</span><br><span class="line">    result1 = arr[0].r - arr[0].l;</span><br><span class="line">    result2 = 0;</span><br><span class="line">    for(i = 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i].l &lt;= arr[j].r)    //如果交叉或相切</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j].r = max(arr[i].r, arr[j].r);</span><br><span class="line">            result1 = max(result1, arr[j].r - arr[j].l);</span><br><span class="line">        &#125;</span><br><span class="line">        else						//如果不交叉也不相切</span><br><span class="line">        &#123;</span><br><span class="line">            result2 = max(result2, arr[i].l - arr[j].r);</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result1 &lt;&lt; &quot; &quot; &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int max(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">	return i &gt; j ? i : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-E-配对元素"><a href="#问题-E-配对元素" class="headerlink" title="问题 E: 配对元素"></a>问题 E: 配对元素</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出2个序列A&#x3D;{a[1]，a[2]，…，a[n]}，B&#x3D;{b[1]，b[2]，…，b[n]}，从A、B中各选出n个元素进行一一配对（可以不按照原来在序列中的顺序），并使得所有配对元素差的绝对值之和最大。</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>输入的第1行为1个整数n 第2行包含n个整数，题目中的A序列。  第3行包含n个整数，题目中的B序列。</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>一个数，最大配对</p>
<p>3与6配对，2与7配对，5与4配对，6与1配对，绝对值之差和为14 对于10%的数据，有n≤20；  对于30%的数据，有n≤100；  对于50%的数据，有n≤1000；  对于100%的数据，有n≤10000；a[i]，b[i]≤1000。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>4<br>2 5 6 3<br>1 4 6 7</p>
</blockquote>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>14</p>
</blockquote>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>首先，利用两个数组A和B存储输入的序列，然后从小到大排序，A中最小和B中最大结合，接着A中次小与B中次大结合，最后，即可得出结果。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">const int max_num = 10000;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, i, sum = 0;</span><br><span class="line">	int A[max_num] = &#123; 0 &#125;, B[max_num] = &#123; 0 &#125;;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for(i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; A[i];</span><br><span class="line">		cin &gt;&gt; B[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(A, A + n);</span><br><span class="line">	sort(B, B + n);</span><br><span class="line">	for(i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += abs(A[i] - B[n - i - 1]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文参考了我矿学长的文章<br><a target="_blank" rel="noopener" href="https://comydream.github.io/2018/10/19/algorithm-experiment-3/">https://comydream.github.io/2018/10/19/algorithm-experiment-3/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%B8%89/" data-id="cl1qb1dxj001qqktueymv5cs5" data-title="CUMTOJ算法实验三" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CUMTOJ算法作业二" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E4%BA%8C/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T16:38:16.000Z" itemprop="datePublished">2019-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E4%BA%8C/">CUMTOJ算法作业二</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="问题-A-单词排序"><a href="#问题-A-单词排序" class="headerlink" title="问题 A: 单词排序"></a>问题 A: 单词排序</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小红学会了很多英文单词，妈妈为了帮小红加强记忆，拿出纸、笔，把 N 个单词写在纸上的一行里，小红看了几秒钟后，将这张纸扣在桌子上。妈妈问小红：“你能否将这 N 个单词按照字典排列的顺序，从小到大写出来？”小红按照妈妈的要求写出了答案。现在请你编写程序帮助妈妈检查小红的答案是否正确。注意：所有单词都由小写字母组成，单词两两之间用一个空格分隔。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入包含两行。</p>
<p>第一行仅包括一个正整数N(0&lt;N≤26)。</p>
<p>第二行包含N个单词，表示妈妈写出的单词，两两之间用一个空格分隔。</p>
<p>单个单词长度不超过1010。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出仅有一行。针对妈妈写出的单词，按照字典排列的顺序从小到大排列成一行的结果，每个单词后带一个空格。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>4<br>city boy tree student</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>boy city student tree </p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，用一个string类型的数组source_str[1010]接收输入原始字符集合，然后，利用选择排序法对数组source_str[1010]进行排序，最后，输出即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string source_str[1010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	void sort(string str[1010], int num);</span><br><span class="line">	int N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    for(int i = 0; i &lt; N; i++)</span><br><span class="line">    	cin &gt;&gt; source_str[i];</span><br><span class="line">    sort(source_str, N);</span><br><span class="line">	for(int j = 0; j &lt; N; j++)</span><br><span class="line">    	cout &lt;&lt; source_str[j] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void sort(string str[1010], int num)</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, k;</span><br><span class="line">	string tmp_str;</span><br><span class="line">	for(int i = 0; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		k = i;</span><br><span class="line">		for(int j = i + 1; j &lt; num; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(str[j] &lt; str[k])</span><br><span class="line">			&#123;</span><br><span class="line">				k = j;</span><br><span class="line">				tmp_str = str[k];</span><br><span class="line">				str[k] = str[i];</span><br><span class="line">				str[i] = tmp_str; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-B-求数组的最长递减子序列"><a href="#问题-B-求数组的最长递减子序列" class="headerlink" title="问题 B: 求数组的最长递减子序列"></a>问题 B: 求数组的最长递减子序列</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入包括两行，第一行包括一个正整数N（N&lt;&#x3D;1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>输出最长递减子序列，数字之间有一个空格。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>8<br>9 4 3 2 5 4 3 2</p>
</blockquote>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>9 5 4 3 2</p>
</blockquote>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先，利用数组source_arr[max_num]存储输入的待排整数序列，然后利用两个for循环将dp[max_num]和last[max_num]设置成如下格式，接着，利用ansa存储结果，最后，输出即可。</p>
<p><img src="https://img-blog.csdnimg.cn/2019092716272557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	const int max_num = 1005;</span><br><span class="line">	int dp[max_num], last[max_num];</span><br><span class="line">    int N, source_arr[max_num], ans = 0, ansp = 1, ansa[max_num];</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)</span><br><span class="line">		cin &gt;&gt; source_arr[i];</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    last[1] = -1;</span><br><span class="line">    for(int i = 2; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        last[i] = -1;</span><br><span class="line">        for(int j = 1; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(source_arr[j] &gt; source_arr[i] &amp;&amp; dp[j] + 1 &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + 1;</span><br><span class="line">                last[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dp[i] &gt; ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = dp[i];</span><br><span class="line">            ansp = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int j = ansp;</span><br><span class="line">    for(int i = ans; ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ansa[i] = source_arr[j];</span><br><span class="line">        if(last[j] == -1)</span><br><span class="line">			break;</span><br><span class="line">        j = last[j];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= ans; i++)</span><br><span class="line">		cout &lt;&lt; ansa[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-C-矩形滑雪场"><a href="#问题-C-矩形滑雪场" class="headerlink" title="问题 C: 矩形滑雪场"></a>问题 C: 矩形滑雪场</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>zcb喜欢滑雪。他来到了一个滑雪场，这个滑雪场是一个矩形，为了简便，我们用r行c列的矩阵来表示每块地形。为了得到更快的速度，滑行的路线必须向下倾斜。 例如样例中的那个矩形，可以从某个点滑向上下左右四个相邻的点之一。例如24-17-16-1，其实25-24-23…3-2-1更长，事实上这是最长的一条。</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>第1行:两个数字r，c(1 ≤ r, c ≤ 100)，表示矩阵的行列。第2..r+1行:每行c个数，表示这个矩阵。</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>仅一行:输出1个整数，表示可以滑行的最大长度。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5 5<br>1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9</p>
</blockquote>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>25</p>
</blockquote>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>二维数组，一看就很难的样子，那我们就把它降维打击一下。二维-&gt;一维。</p>
<p>怎么实现呢？</p>
<ol>
<li>定义结构体<code>node</code>，存储坐标<code>x</code>，<code>y</code>和高度<code>h</code>；<br>一般在定义后在<code>&#125;</code>和<code>;</code>之间直接定义数组</li>
<li>写一个<code>bool check(int i,int j)</code>函数，用来判断两点是否为相邻点（上、下、左、右）；</li>
</ol>
<p>以上为main()函数中的实现做铺垫。</p>
<ol>
<li><p>输入时怎么处理？直接两层for：（比较巧妙）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ski[n].x = i;</span><br><span class="line">ski[n].y = j;</span><br><span class="line">cin &gt;&gt; ski[n].h;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入完后sort()一下，注意在结构体中重载下&lt;，按h从大到小排；</p>
</li>
<li><p>这样就有点像DP：最长上升子序列问题了</p>
</li>
</ol>
<ul>
<li>初始化<code>dp[i] = 1</code></li>
<li>此时，对于第<code>i</code>个结点，前面的结点<code>j</code>的<code>h</code>都更大，那就判断下每个点是否是相邻点（前面定义的<code>check()</code>函数），若是，则执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i],dp[j]+1);</span><br></pre></td></tr></table></figure>

<ul>
<li>最后的ans是dp[i]数组的最大值</li>
</ul>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 5e4 + 1;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int x, y, h;</span><br><span class="line">    bool operator &lt; (const node &amp;c) const</span><br><span class="line">    &#123;</span><br><span class="line">        return h &gt; c.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ski[max_num];</span><br><span class="line">int dp[max_num];</span><br><span class="line">int r, c;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	bool check(int i, int j);</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line">	cin &gt;&gt; c;</span><br><span class="line">    int n = 0;</span><br><span class="line">    for(int i = 1; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 1;j &lt;= c; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ski[n].x = i;</span><br><span class="line">            ski[n].y = j;</span><br><span class="line">            cin &gt;&gt; ski[n].h;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ski, ski + n);</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        for(int j = 0; j &lt; i; j++)</span><br><span class="line">            if(check(i, j))</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">        ans = max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    if(abs(ski[i].x - ski[j].x) + abs(ski[i].y - ski[j].y) == 1)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-E-区间包含问题"><a href="#问题-E-区间包含问题" class="headerlink" title="问题 E: 区间包含问题"></a>问题 E: 区间包含问题</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知 n 个左闭右开区间 [a,b)，对其进行 m 次询问，求区间[l,r]最多可以包含 n 个区间中的多少个区间，并且被包含的所有区间都不相交。</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入包含多组测试数据，对于每组测试数据：</p>
<p>第一行包含两个整数 n ,m (1≤n≤100000,1≤m≤100) 。</p>
<p>接下来 n 行每行包含两个整数 a ,b (0 ≤ a &lt; b ≤ 10^9) 。</p>
<p>接下来 m 行每行包含两个整数 l ,r (0 ≤ l &lt; r ≤ 10^9)  。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出 m 行，每行包含一个整数。</p>
<p>数据过大请使用快速输入输出。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>4 3<br>1 3<br>2 4<br>1 4<br>1 2<br>1 2<br>1 3<br>1 4</p>
</blockquote>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1<br>1<br>2</p>
</blockquote>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>输入结束后，把所有活动按结束时间从小到大排序。</p>
<p>定义<code>ans</code>，先给它赋值1。</p>
<p>循环遍历所有活动，符合不相交、不越界就可选。</p>
<ul>
<li><p>千万别写if(e &#x3D;&#x3D; c.e) return b &lt; c.b;否则必定WA，不知为何。</p>
</li>
<li><p>千万要在结束时间超过r后跳出循环，不然必定TLE。</p>
</li>
<li><p>千万不要用cin、cout，不然好像也是必定TLE。</p>
</li>
</ul>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 1e5 + 5;</span><br><span class="line">struct s</span><br><span class="line">&#123;</span><br><span class="line">	int b, e;</span><br><span class="line">	bool operator &lt; (const s&amp;c) const</span><br><span class="line">	&#123;</span><br><span class="line">		//if(e == c.e) return b &lt; c.b;</span><br><span class="line">		return e &lt; c.e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; interval[max_num];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, m, l, r;</span><br><span class="line">	while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 0; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d %d&quot;, &amp;interval[i].b, &amp;interval[i].e);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(interval, interval + n);</span><br><span class="line">		for (int cas = 0; cas &lt; m; cas++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d %d&quot;, &amp;l, &amp;r);</span><br><span class="line">			int j = 0, ans = 0;</span><br><span class="line">			while (interval[j].b &lt; l)</span><br><span class="line">				j++;</span><br><span class="line">			for (int i = j; i &lt; n &amp;&amp; interval[i].e &lt;= r; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				if (interval[i].b &gt;= interval[j].e || i == j)</span><br><span class="line">				&#123;</span><br><span class="line">					ans++;</span><br><span class="line">					j = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%d\n&quot;, ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-F-最长子序列"><a href="#问题-F-最长子序列" class="headerlink" title="问题 F: 最长子序列"></a>问题 F: 最长子序列</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个数组中找出和最大的连续几个数。（至少包含一个数）</p>
<p>例如：</p>
<p>数组A[] &#x3D; [-2,1,-3,4,-1,2,1,-5,4]，则连续的子序列[4,-1,2,1]有最大的和6.</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>第一行输入一个不超过1000的整数n。</p>
<p>第二行输入n个整数A[i]。</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，表示最大的和。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>3<br>1 1 -2</p>
</blockquote>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>2</p>
</blockquote>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>此题类似于我前面写过的一篇文章《CUMTOJ算法实验二》，具体思路就是最大子段和的求解，详解见如下链接</p>
<p><a target="_blank" rel="noopener" href="https://xingshuaikun.gitee.io/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%BA%8C/">https://xingshuaikun.gitee.io/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%BA%8C/</a></p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 10000;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int max(int a, int b);</span><br><span class="line">	int n, arr[max_num], A[max_num] = &#123; 0 &#125;;</span><br><span class="line">	while (cin &gt;&gt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		int result = 0;</span><br><span class="line">		for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; arr[i];</span><br><span class="line">			if (A[i - 1] &gt; 0)</span><br><span class="line">				A[i] = A[i - 1] + arr[i];</span><br><span class="line">			else</span><br><span class="line">				A[i] = arr[i];</span><br><span class="line">			result = max(result, A[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	return (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-G-元素整除问题"><a href="#问题-G-元素整除问题" class="headerlink" title="问题 G: 元素整除问题"></a>问题 G: 元素整除问题</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入20个整数，输出其中能被数组中其它元素整除的那些数组元素。</p>
<h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>输入20个整数</p>
<h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>按输入顺序输出符合要求的数字，每行输出一个整数。</p>
<h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</p>
</blockquote>
<h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>4<br>6<br>8<br>9<br>10<br>12<br>14<br>15<br>16<br>18<br>20<br>21</p>
</blockquote>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>首先，用一个数组a存储输入的20个数字，然后，利用continue处理不能求余的数并将其输出即可。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int arr_num = 20;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, k, a[arr_num];</span><br><span class="line">	k = 0;</span><br><span class="line">	for (i = 0; i &lt; arr_num; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	for (i = 0; i &lt; arr_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		k = i;</span><br><span class="line">		a[k] = a[i];</span><br><span class="line">		for (j = 0; j &lt; arr_num; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (k == j)</span><br><span class="line">			&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				if (a[k] % a[j] == 0)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; a[k] &lt;&lt; endl;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-H-渊子赛马"><a href="#问题-H-渊子赛马" class="headerlink" title="问题 H: 渊子赛马"></a>问题 H: 渊子赛马</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。 赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。” 孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 就是这么简单，现在渊子也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。渊子有 N(1&lt;&#x3D;n&lt;&#x3D;1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看渊子能否赢得比赛。</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>输入有多组测试数据。 每组测试数据包括 3 行： 第一行输入 N。表示马的数量。 第二行有 N 个整型数字，即渊子的 N 匹马的速度。 第三行有 N 个整型数字，即对手的 N 匹马的速度。 当 N 为 0 时退出。</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出YES。 否则输出NO。</p>
<h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>2 3 3 4 5<br>1 2 3 4 5<br>4<br>2 2 1 2<br>2 2 3 1<br>0</p>
</blockquote>
<h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>YES<br>NO</p>
</blockquote>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>首先，利用两个数组yuanZi和duiShou存储输入的n个数字，然后，利用排序函数sort()对两个函数进行排序，接着，不是最大的与最小的相比较，而是挑较大的与较小的比较，用一个win存储能赢的局数。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 1000;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int yuanZi[max_num] = &#123; 0 &#125;, duiShou[max_num] = &#123; 0 &#125;, i, j, win = 0, n, t, k;</span><br><span class="line">	while (cin &gt;&gt; n &amp;&amp; n != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		for (j = 0; j &lt; n; j++)</span><br><span class="line">			cin &gt;&gt; yuanZi[j];</span><br><span class="line">		for (j = 0; j &lt; n; j++)</span><br><span class="line">			cin &gt;&gt; duiShou[j];</span><br><span class="line">		sort(yuanZi, yuanZi + n);</span><br><span class="line">		sort(duiShou, duiShou + n);</span><br><span class="line">		for (i = 0, j = 0, win = 0; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (yuanZi[i] &gt; duiShou[j])</span><br><span class="line">			&#123;</span><br><span class="line">				win++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (win &gt; n / 2)</span><br><span class="line">			cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">		else</span><br><span class="line">			cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-I-最长上升子序列"><a href="#问题-I-最长上升子序列" class="headerlink" title="问题 I: 最长上升子序列"></a>问题 I: 最长上升子序列</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个长度为n的字符串S（只包含小写字母），给出q次查询，对于每次查询x，求出以S[x]（下标从0开始）为起始的最长上升子序列的长度（严格增）。</p>
<h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>第一行两个整数n,q(1&lt;&#x3D;n,q&lt;&#x3D;1e5)，意义见题目描述。</p>
<p>第二行一个长度为n的字符串S。</p>
<p>第三行q个整数x(0 &lt;&#x3D; x &lt; n)，表示q次查询。</p>
<h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>输出q个数（以空格分割，行末有空格），表示以S[x]为起始的最长上升子序列的长度。</p>
<h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10 3<br>abbaaccbbd<br>2 5 8</p>
</blockquote>
<h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>3 2 2</p>
</blockquote>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>首先，用一个数组S存储输入的长度为n的字符串，然后，利用LIS()函数求最长上升子序列，在我电脑上结果正确，但在OJ上就是运行错误50%，不管了，这一题就这样了。</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 1000;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int LIS(char A[], int n);</span><br><span class="line">	int n, q, tmp[max_num] = &#123; 0 &#125;;</span><br><span class="line">	char S[max_num] = &#123; &#x27;\0&#x27; &#125;;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; S[i];</span><br><span class="line">	for (int j = 0; j &lt; q; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; tmp[j];</span><br><span class="line">		char tmp_str[max_num] = &#123; &#x27;\0&#x27; &#125;;</span><br><span class="line">		for (int y = 0; y &lt; n - tmp[j]; y++)</span><br><span class="line">			tmp_str[y] = S[y + tmp[j]];</span><br><span class="line">		cout &lt;&lt; LIS(tmp_str, n - tmp[j]) &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int LIS(char A[], int n)</span><br><span class="line">&#123;</span><br><span class="line">	int* d = new int[n];</span><br><span class="line">	int len = 1;</span><br><span class="line">	int i, j;</span><br><span class="line">	for (i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d[i] = 1;</span><br><span class="line">		for (j = 0; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (A[j] &lt; A[i] &amp;&amp; (d[j] + 1) &gt; d[i])</span><br><span class="line">				d[i] = d[j] + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		if (d[i] &gt; len) len = d[i];</span><br><span class="line">	&#125;</span><br><span class="line">	delete[] d;</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-J-区间第k小"><a href="#问题-J-区间第k小" class="headerlink" title="问题 J: 区间第k小"></a>问题 J: 区间第k小</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>花花上算法课又偷偷摸鱼。她今天刚学会如何求解区间第k小的数，但是感觉没什么意思。于是她将题目稍稍改动了一下：对于一个长度为n的数列a来说，一共有n*(n+1)&#x2F;2个子区间，对于数列a的每一个子区间，如果这个子区间的长度小于k，我们不管它，否则把该子区间的第k小的数加入新数列b（初始为空）。花花并不关心数列b里面的元素是什么，她只想知道新数列b中第k小的元素是多少。</p>
<p>例如，一个长度为4的数列a&#x3D;{5,3,4,9}，当k取3时只有三个子区间长度是&gt;&#x3D;3的：{5,3,4},{3,4,9}和{5,3,4,9}。分别提取各自的第3小的数加入b数列得到{5,9,5},其中第3小的数为9。</p>
<h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>第一行两个数n，k（1&lt;&#x3D;n, k&lt;&#x3D;1e5）意义见题目描述</p>
<p>第二行n个数表示数列a中的元素ai。(1&lt;&#x3D;ai&lt;&#x3D;1e9)</p>
<p>数据保证数列b中的元素个数不少于k个</p>
<h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>输出一个数，表示数列b中的第k小的数</p>
<h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>4 3<br>5 3 4 9</p>
</blockquote>
<h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>9</p>
</blockquote>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>本人不才，没找到最终答案，所以就给出求一个数组的第k小的代码。</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 100000;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int arr[max_num] = &#123; 0 &#125;;</span><br><span class="line">	int n, k, i;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	for(i = 0; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	sort(arr, arr + n);</span><br><span class="line">    cout &lt;&lt; arr[k - 1] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A%E4%BA%8C/" data-id="cl1qb1dxh001jqktubv6x1l7p" data-title="CUMTOJ算法作业二" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CUMTOJ算法实验二" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%BA%8C/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T16:38:16.000Z" itemprop="datePublished">2019-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%BA%8C/">CUMTOJ算法实验二</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="问题-A-最长公共子序列"><a href="#问题-A-最长公共子序列" class="headerlink" title="问题 A: 最长公共子序列"></a>问题 A: 最长公共子序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。<br>例如：Z&#x3D;&lt;a,b,f,c&gt;是序列X&#x3D;&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。<br>现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>对于每组输入，输出两个字符串的最长公共子序列的长度。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>abcfbc abfcab<br>programming contest<br>abcd mnp</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>4<br>2<br>0</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用c[i][j]记录x序列前i个元素和y序列前j个元素的最长公共子序列长度。</p>
<p>确定初始状态的值：i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0时，c[i][j] &#x3D; 0。</p>
<p>状态转移方程：</p>
<p>if(x[i] &#x3D;&#x3D; y[j]) c[i][j] &#x3D; c[i-1][j-1]+1;<br>else c[i][j] &#x3D; max(c[i-1][j],c[i][j-1]);<br>最后，c[lenx][leny]就是最长公共子序列的长度。</p>
<p>那么如何构造最优解呢？</p>
<p>新开一个二维数组，叫做b[i][j]：</p>
<p>（x[i] &#x3D;&#x3D; y[j]）如果c[i][j]是由左上得到，则b[i][j] &#x3D; 1<br>（x[i] !&#x3D; y[j]）如果c[i][j]是由上方得到，则b[i][j] &#x3D; 2<br>（x[i] !&#x3D; y[j]）如果c[i][j]是由左方得到，则b[i][j] &#x3D; 3<br>注：若x[i] !&#x3D; y[j]情况下左和上相等统一记为b[i][j] &#x3D; 2</p>
<p>最后，由b数组倒推可得到最优解。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int max_num = 1000;</span><br><span class="line">    int arr[max_num][max_num];</span><br><span class="line">    int len_fir, len_sec;</span><br><span class="line">    char fir_str[max_num], sec_str[max_num];</span><br><span class="line">    while(cin &gt;&gt; fir_str &gt;&gt; sec_str)</span><br><span class="line">    &#123;</span><br><span class="line">        len_fir = strlen(fir_str);</span><br><span class="line">        len_sec = strlen(sec_str);</span><br><span class="line">        memset(arr, 0, sizeof(arr));</span><br><span class="line">        for(int i = 1; i &lt;= len_fir; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt;= len_sec; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(fir_str[i-1] == sec_str[j-1])</span><br><span class="line">                    arr[i][j] = arr[i-1][j-1] + 1;</span><br><span class="line">                else</span><br><span class="line">                    arr[i][j] = max(arr[i-1][j], arr[i][j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; arr[len_fir][len_sec] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-B-矩阵连乘"><a href="#问题-B-矩阵连乘" class="headerlink" title="问题 B: 矩阵连乘"></a>问题 B: 矩阵连乘</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定n个矩阵{A1,A2,…,An}，及m个矩阵连乘的表达式，判断每个矩阵连乘表达式是否满足矩阵乘法法则，如果满足，则计算矩阵的最小连乘次数，如果不满足输出“MengMengDa“。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入数据由多组数据组成（不超过10组样例）。每组数据格式如下：<br>第一行是2个整数n (1≤n≤26)和m(1≤m≤3)，表示矩阵的个数。<br>接下来n行，每行有一个大写字母，表示矩阵的名字，后面有两个整数r和c，分别表示该矩阵的行数和列数，其中1 &lt; r, c &lt; 100。<br>第n+1行到第n+m行，每行是一个矩阵连乘的表达式(2 &lt;&#x3D; 矩阵个数 &lt;&#x3D; 100)。</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>对于每个矩阵连乘表达式，如果运算不满足矩阵乘法法则的情况（即左矩阵列数与右矩阵的行数不同），则输出“MengMengDa”，否则输出最小矩阵连乘次数。</p>
<p>数据保证结果不超过1e9。<br>对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>3 2<br>A 10 100<br>B 5 50<br>C 100 5<br>ACB<br>ABC</p>
</blockquote>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>7500<br>MengMengDa</p>
</blockquote>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>先来回顾下我们上课学的矩阵连乘填表方法，我们把它封装成一个MatrixChain()函数。</p>
<p>回忆一下填表的过程，首先，因为如果只有一个矩阵的话，那就不需要乘了，结果肯定是0，对应地，我们把对角线全部置为0。for(int i &#x3D; 1; i &lt;&#x3D; n; i++) dp[i][i] &#x3D; 0;</p>
<p>然后写一个三层循环：</p>
<ol>
<li><p>第一层循环r从2到n，代表连乘矩阵的个数</p>
</li>
<li><p>第二层循环i从1到n-r+1，代表左界下标<br>这时候右界下标j就等于i+r-1</p>
</li>
<li><p>第三层循环k从i到j-1，代表隔板位置，这个隔板把原来的问题一分为二</p>
</li>
</ol>
<p>书上的代码把那个表对应的二维矩阵叫做m[i][j]，因为输入也叫m，所以我们就叫它dp[i][j]吧。</p>
<p>这样，让dp[i][j]中存储的是dp[i][k] + dp[k + 1][j] + p[i - 1] * p[k] * p[j]的最小值。</p>
<p>先输入n个矩阵的名字（单个字符）、行数和列数。这时候我们可以使用一个数据结构——map，这种容器使用红黑树实现，插入、查找、删除的时间复杂度都是O(logn)。</p>
<p>注意：虽是单个字符，若让C++读入单个字符，可以为’\n，为了避免使用getchar()函数，通常使用元素个数为2的char数组存储单个字符。</p>
<p>m次query，每次读入一个字符串。令len &#x3D; strlen(str)，若len个矩阵可连乘（对于每两个连续矩阵，前一个矩阵的列数&#x3D;后一个矩阵的行数），则输出最小矩阵连乘次数，否则输出“MengMengDa”。</p>
<p>首先，不满足矩阵乘法法则的情况好判断，遍历一遍len个矩阵，若左矩阵列数与右矩阵的行数不同，则直接输出“MengMengDa”并break；<br>若满足矩阵连乘条件，则我们要构造p数组，构造过程参考代码；<br>可以封装一个void MatrixChain(int p[],int n)函数，用于执行dp，调用该函数后，结果就是dp[1][len]</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 1005;</span><br><span class="line">int dp[max_num][max_num];</span><br><span class="line">struct Matrix &#123;</span><br><span class="line">    int r, c;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	void MatrixChain(int p[], int n);</span><br><span class="line">    int n, m;</span><br><span class="line">    while(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;char, Matrix&gt; dir;</span><br><span class="line">        char nam[8], str[105];</span><br><span class="line">        int r, c;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; nam;</span><br><span class="line">            cin &gt;&gt; r;</span><br><span class="line">            cin &gt;&gt; c;</span><br><span class="line">            Matrix tmp;</span><br><span class="line">            tmp.r = r;</span><br><span class="line">            tmp.c = c;</span><br><span class="line">            dir[nam[0]] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int cas = 0; cas &lt; m; cas++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            int len = strlen(str);</span><br><span class="line">            int p[max_num];</span><br><span class="line">            p[0] = dir[str[0]].r;</span><br><span class="line">            p[1] = dir[str[0]].c;</span><br><span class="line">            bool flag = true;</span><br><span class="line">            for(int i = 1; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(dir[str[i]].r != dir[str[i-1]].c)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                p[i + 1] = dir[str[i]].c;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!flag)</span><br><span class="line">				cout &lt;&lt; &quot;MengMengDa&quot; &lt;&lt; endl;</span><br><span class="line">            else &#123;</span><br><span class="line">                MatrixChain(p, len);</span><br><span class="line">                cout &lt;&lt; dp[1][len] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void MatrixChain(int p[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">		dp[i][i] = 0;</span><br><span class="line">    for(int r = 2; r &lt;= n; r++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1; i &lt;= n - r + 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = i + r - 1;</span><br><span class="line">            dp[i][j] = dp[i + 1][j] + p[i-1] * p[i] * p[j];</span><br><span class="line">            for(int k = i + 1; k &lt; j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                int t = dp[i][k] + dp[k + 1][j] + p[i-1] * p[k] * p[j];</span><br><span class="line">                dp[i][j] = min(dp[i][j], t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-C-01背包问题"><a href="#问题-C-01背包问题" class="headerlink" title="问题 C: 01背包问题"></a>问题 C: 01背包问题</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知有N种物品和一个可容纳C重量的背包。每种物品i的重量为Wi，价值为Pi。那么，采用怎样的装包方法才会使装入背包物品的总价值最大。</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>包含多组测试数据。第一行为一个整数T(1&lt;&#x3D;T&lt;&#x3D;10)，代表测试数据个数。</p>
<p>接下来有T组测试数据。每组测试数据第一行为背包的重量C(C&lt;10000)和物品个数N(N&lt;1000)。接下来的N行分别为物品的重量cost(1&lt;&#x3D;cost&lt;&#x3D;100)和价值val(1&lt;&#x3D;val&lt;&#x3D;3000000)。（注意：结果可能超过int范围）</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>对每组测试数据，输出其对应的所装物品的最大价值。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>1<br>10 5<br>2 6<br>2 3<br>6 5<br>5 4<br>4 6</p>
</blockquote>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>15</p>
</blockquote>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>先看题目最后的注意，结果可能超过int范围，故采用long long类型。我一般这样写：typefef long long ll;把它“重命名”一下，以后写起来比较简便。</p>
<p>注意在stdio（scanf、printf）中，要写出%lld。</p>
<p>有两种写法（分别对应下面的代码1和代码2）.</p>
<p>第一种，也就是书上的这种，arr[i][j]代表从第i件物品开始的、在最大容量为j的情况下可以获得的最大收益，最后结果保存在arr[1][c]；</p>
<p><img src="https://img-blog.csdnimg.cn/20190923164729570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int max_num = 1005;</span><br><span class="line">ll arr[max_num][max_num];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t, n;</span><br><span class="line">    ll c, w[max_num], v[max_num];</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%lld %d&quot;, &amp;c, &amp;n);</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">            scanf(&quot;%lld %lld&quot;, &amp;w[i], &amp;v[i]);</span><br><span class="line">        int i, j, jMax = min(w[n] - 1, c);</span><br><span class="line">        for(j = 0; j &lt;= jMax; j++)</span><br><span class="line">			arr[n][j] = 0;</span><br><span class="line">        for(j = w[n]; j &lt;= c; j++)</span><br><span class="line">			arr[n][j] = v[n];</span><br><span class="line">        for(i = n - 1; i &gt; 1; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            jMax = min(w[i] - 1, c);</span><br><span class="line">            for(j = 0; j &lt;= jMax; j++)</span><br><span class="line">				arr[i][j] = arr[i + 1][j];</span><br><span class="line">            for(j = w[i]; j &lt;= c; j++)</span><br><span class="line">				arr[i][j] = max(arr[i + 1][j] , arr[i + 1][j-w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[1][c] = arr[2][c];</span><br><span class="line">        if(c &gt;= w[1])</span><br><span class="line">			arr[1][c] = max(arr[1][c], arr[2][c-w[1]] + v[1]);</span><br><span class="line">        printf(&quot;%lld\n&quot;, arr[1][c]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-D-最大子段和"><a href="#问题-D-最大子段和" class="headerlink" title="问题 D: 最大子段和"></a>问题 D: 最大子段和</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定n个整数组成的序列a1,a2,…an, 求子段和ai+ai+1+…+aj（子段可为空集）的最大值。</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>包含多组测试数据。第一行为一个整数T(1&lt;&#x3D;T&lt;&#x3D;20)，代表测试数据个数。</p>
<p>每组测试数据第一行为一个整数n，代表有n个整数(1&lt;&#x3D;n&lt;&#x3D;10000)。</p>
<p>接下来一行有n个数x(-1000&lt;&#x3D;x&lt;&#x3D;1000)。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>输出其对应的最大子段和。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>1<br>6<br>2 -11 4 13 -1 2</p>
</blockquote>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>18</p>
</blockquote>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>DP基础题，新开一个b辅助数组，我们这样定义它：auxiliary_arr[j]存储选取第j个元素时arr[1],…,arr[j]的最大子段和。</p>
<p>递归定义auxiliary_arr数组（b[0]需初始化为0）：</p>
<p>（前面为正数，有用则要）若auxiliary_arr[j-1] &gt; 0，则</p>
<pre><code>auxiliary_arr[j] = auxiliary_arr[j-1] + arr[j]；
</code></pre>
<p>（前面为负数，无用则丢）否则</p>
<pre><code>auxiliary_arr[j] = arr[j]
</code></pre>
<p>则易得出最优值为b数组中的最大值（因为题目要求若为负数则输出0，所以要和0做一次max）。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 10000;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t, n, arr[max_num], auxiliary_arr[max_num]= &#123; 0 &#125;;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">            if(auxiliary_arr[i-1] &gt; 0)</span><br><span class="line">				auxiliary_arr[i] = auxiliary_arr[i - 1] + arr[i];</span><br><span class="line">            else</span><br><span class="line">				auxiliary_arr[i] = arr[i];</span><br><span class="line">            result = max(result, auxiliary_arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-E-汽水瓶【25】"><a href="#问题-E-汽水瓶【25】" class="headerlink" title="问题 E: 汽水瓶【25】"></a>问题 E: 汽水瓶【25】</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n(1≤n≤100)，表示小张手上的空汽水瓶数。n&#x3D;0表示输入结束，你的程序不应当处理这一行。</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出 0</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>3<br>10<br>81<br>0</p>
</blockquote>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1<br>5<br>40</p>
</blockquote>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>result 存储这一轮完成后的结果，emp 存储这一轮完成后的空瓶数。</p>
<p>题目怎么来，我们就怎么写代码。模拟一下，用 tmp 存储这一轮喝的汽水的瓶数，则有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result += tmp;</span><br><span class="line">emp = emp % 3 + tmp;</span><br></pre></td></tr></table></figure>

<p>循环的条件是什么？答案很显然是 while(emp &gt;&#x3D; 2)。</p>
<p>emp &#x3D;&#x3D; 2 的时候怎么处理？答案是先借一瓶，即 emp++。</p>
<p>最终，输出 result 即可。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while((cin &gt;&gt; n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        int result = 0, emp = n, tmp;</span><br><span class="line">        while(emp &gt;= 2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(emp == 2)</span><br><span class="line">				emp++;</span><br><span class="line">            tmp = emp / 3;</span><br><span class="line">            result += tmp;</span><br><span class="line">            emp = emp % 3 + tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文参考了我矿学长的文章<br><a target="_blank" rel="noopener" href="https://comydream.github.io/2018/10/09/algorithm-experiment-2/">https://comydream.github.io/2018/10/09/algorithm-experiment-2/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/12/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%BA%8C/" data-id="cl1qb1dxk001tqktuckvxfc5i" data-title="CUMTOJ算法实验二" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-区块链详解（转）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T16:38:16.000Z" itemprop="datePublished">2019-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%EF%BC%89/">区块链详解（转）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文转载于<a target="_blank" rel="noopener" href="https://blog.csdn.net/taifei/article/details/80596763">https://blog.csdn.net/taifei/article/details/80596763</a></p>
<h1 id="区块链详解（转）"><a href="#区块链详解（转）" class="headerlink" title="区块链详解（转）"></a>区块链详解（转）</h1><div id="article_content" class="article_content clearfix">
                                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
                                        <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
                <div class="htmledit_views" id="content_views">
                                            <p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">侠客岛按】</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　上个月，我岛在杭州举办了线下沙龙，邀请了蚂蚁金服技术实验室高级技术专家邓福喜，和大家聊了聊最近大热的区块链技术。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　在千呼万唤中，岛叔今天终于把文字整理好了。大家不用在后台催了!</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　三千多字的文字整理稿中，干货很多。邓老师把区块链的概念讲得挺清楚，包括其应用场景和大家最感兴趣的比特币等等。同时也厘清了大家对区块链的一些误解。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　以下为岛叔整理的文字实录，看完，相信区块链对你来说将不再神秘。(这里再透露一下，文末有福利哦。)</p><p align="center" style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);"><img src="http://p0.ifengimg.com/pmop/2018/0605/A289A92DAB5C07FACF1B519B9B812B7246D2A5EE2_size94_w1080_h720.jpeg" alt="" width="580" height="387" border="0" style="padding:0px;border:none;"></p><address style="margin:0px;padding:0px;color:rgb(0,0,0);font-family:Simsun;font-size:14px;background-color:rgb(255,255,255);text-align:center;">　　蚂蚁金服技术实验室高级技术专家邓福喜</address><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　实际上区块链最早可以追溯到2009年，那时一个很神秘的人叫中本聪，提出了区块链的概念，同时给出了一个初始的设计和实现，也就是现在广为人知的比特币。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　现在大家对区块链技术的了解，更多可能是停留在用比特币炒币，或者市场上发行的一些奇奇怪怪的加密货币上，比如马勒戈币等等。这些乱象，确实使大家对区块链产生了较大的误解。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　其实就区块链本身来说，它是一项技术，技术本身并没有错。今天，越来越多的人渴望了解区块链的本质，我也希望能够通过一些简单的介绍，让大家直观地了解到区块链究竟是什么?它在我们日常生活中可以解决什么问题?</p><p align="center" style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);"><img src="http://p0.ifengimg.com/pmop/2018/0605/A68845781B6AE6D001016A21B1332ABCBE36C97F5_size87_w1080_h606.jpeg" alt="" width="580" height="325" border="0" style="padding:0px;border:none;"></p><address style="margin:0px;padding:0px;color:rgb(0,0,0);font-family:Simsun;font-size:14px;background-color:rgb(255,255,255);text-align:center;">　　区块链</address><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　首先，区块链并不高深，它其实就是一个多方参与的加密分布式记账本。这里面有三个关键词：记账本、加密和分布式，搞明白这三个词，其实对区块链技术就会有一个比较明晰的理解了。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　首先是第一个关键词：记账本。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　这个账本其实就像我们的银行账户一样，你在某一个银行里面有多少钱，今天花了多少等等，这些都是有记账的。我们再拿比特币交易的例子来说，一笔比特币交易完成之后，比特币的区块链上就会记住你购进购出多少比特币的流水，这些条目会在你的账户中，你的账户就是一个账本。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　这个账本可不是普通的账本，它前面有一个定语，叫多方参与。多方参与意味着什么?这个账本不是一个人去记的，也不是一个中心化机构去记的，而是由分散在全球各个角落的人一起记。甚至借助于卫星系统，接下来可能还会分布在星空中。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　这和我们平常在各个银行中开户存钱，然后再分别让各个银行给我们记账可大不相同。无论你分散在世界哪里，只要你有一台电脑，你就可以进入这个数据库，看看A交易了10个比特币，或者B交易了100个比特币等等。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　第二个关键词是加密。加密的意思就是通过一个密码学的手段，保证你的账户不会被别人篡改。这就和现在我们去银行转账，他们通常会给你一个U盾一样，这个U盾就相当于你账户的一把钥匙，只有拥有钥匙的人才能操作这个账户，才能进行转账。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　在区块链里面也有这个概念。你在区块链开户的时候，系统会自动创建一把钥匙，有了这个钥匙才可以操作区块链上的账户。这把钥匙的产生，和使用钥匙进行账户操作的一些判断，都来源于这个加密学手段。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　第三个关键词叫做分布式。分布式的意思是说，区块链这个多方参与的节点，实际上是分布在全球的任何一个网络节点里面，他不归属于一个特定的机构。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　像现在在BAT的一些系统里，存在有很多服务器，这个服务器我们也可以说他是多方参与的，但是我们不能说他是分布式的。为什么呢?因为分布式有两个原则：一是它在物理位置上是分布式的;二，它在规则上面也是分布式的。但是像BAT他们的服务器，是归属于一个特定机构或者特定的个体的，这不能叫分布式。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　理解这三点，其实就能把区块链整个串起来了：区块链就是分散在全球的所有的离散的点上的多个机器，维护一个特定的账户系统，而这种系统通过一种密码学的手段，可以保证操作时比较规矩的一项技术。可以这样简单地去理解区块链。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　如果你还没搞清楚的话，我用小虎队的《爱》这首歌来讲，可能会更形象。这首歌简直就像是为区块链写的。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　向天空大声的呼唤说声我爱你 向那流浪的白云说声我想你 让那天空听得见、 让那白云看得见 谁也擦不掉我们许下的诺言 ……</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　这里面出现的“天空”“白云”“蓝天”“大海”，我们就可以理解成一个个节点，当你向他们喊出“我爱你”的时候，这些节点就默默的把账记录在数据库上了，然后大家都能看见。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　记录下来之后，歌词里的“谁也擦不掉我们许下的诺言”，擦不掉的意思就是说，我只要记下来以后，这个就成为一个恒久不变的一个东西，这样的话女生就会觉得特别的安全，如果有一天这个男生反悔了，这个女生就可以在所谓的“天空”“白云”上找到他当初的表白，证明他的确说过这个事，这是一个比较形象的理解。</p><p align="center" style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);"><img src="http://p0.ifengimg.com/pmop/2018/0605/A683BE2E65C54BF4089EB7BFEA308D8394E0CA2FE_size116_w1080_h724.jpeg" alt="" width="580" height="389" border="0" style="padding:0px;border:none;"></p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　比特币</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　很多人对比特币很好奇，不明白他和区块链之间到底有什么关系，接下来和大家聊聊这个。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　要想了解比特币，我们我们先要明白比特币究竟是如何记账的。前面提到了，区块链里每个人都有一本账本，那么到底由谁来记账?我记的帐为什么别人要认?这又引出一个共识算法的问题，即如何保证大家记的账是一致的。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　比如，我给用户A 10个比特币，A收到了10个比特币，这个记账的过程是透明的。但这笔账，并不是A他自己记的，而是依靠系统里面的一个所谓的共识算法，大家一起来决定由某一个人记账。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　这样有一个好处，就是每次记账的人都不一样，就可以避免某人知道谁下一个记账，去贿赂贿赂他，让他弄个假账这种情况出现了。这个时候，就会更加公平公正。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　所以在比特币里，就采取一种叫做竞争记账的方式，大家都去抢记账的权力，抢到之后就可以获得记账奖励。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　我们可以用国粹打麻将来做一个比喻。</p><p align="center" style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);"><img src="http://p0.ifengimg.com/pmop/2018/0605/A63A8B0C917AC68E20102EE0E0A9119C34B540ECD_size69_w1080_h603.jpeg" alt="" width="580" height="324" border="0" style="padding:0px;border:none;"></p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　我们打麻将不就是不断地去摸牌打牌，最终胡牌的一个过程吗?四个“矿工”一组，最先从144个随机数字中，一人一次摸牌机会，碰撞出一组牌，谁先胡了谁就赢了，获得收益，也获得记账权。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　因为胡牌的过程是随机的，有可能跟你打牌的策略有关，也有可能跟你的运气有关等等，反正每个人都是凭本事来嘛。大家都认这个结果，然后开始下一轮记账权。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　但是，和打麻将不同的是，这个随机的过程要比胡牌难度高得多。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　如果打麻将算是解一元一次方程的话，那比特币挖矿可能就相当于一元一万次方程那样了，难度是指数级增长的。这种情况下，计算机高手就选择了另一种方式，我不一点一点算，我直接通过尝试的办法试出来。有点类似于暴力破解的感觉。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　通过不断去尝试，谁第一个解出来，那么谁就获得这个记账权，也就是获得了记账奖励——比特币。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　区块链≠ICO</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　现在很多人一提区块链，就认为是骗人的，这其实和之前的市场乱象有关。其实我们应该区分一个概念，ICO和区块链没有半毛钱关系。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　ICO中文翻译过来叫首次货币发行。大家可能会想到另外一个类似的词叫IPO，这是第一次公开募集资金的意思。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　ICO和IPO之间本质的区别是，IPO有监管，而ICO可以帮助那些不能发售股票的企业，绕开IPO，绕开监管，让发展更为初期的公司有了一个更加灵活的融资手段。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　而这个ICO的平台，正是借助于区块链技术支持下的以太坊。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　简单地说，就是这个以太坊可以让每个人都能生成自己的虚拟货币，基本没有门槛。里面起什么名字的都有，有人还发行了“马勒戈币”。这也是让大家对区块链产生很大误解的一个地方。</p><p align="center" style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);"><img src="http://p0.ifengimg.com/pmop/2018/0605/A047340A47A4E47FECC83151449FC564D14D7FEEA_size40_w624_h538.jpeg" alt="" width="624" height="538" border="0" style="padding:0px;border:none;"></p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　目前，ICO还没有一个规章制度去规范，所以就变得特别没有章法。所以现在很多坏人在利用ICO，放大人性中的贪婪，然后去变相募集大家的资金，摧毁了人与人的信任。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　另外，ICO和数字货币也是两码事。数字货币是具有法定发币机构背书的，具有权威性、具有最高价值信任的法币，是与纸币有同等价值和使用效力的。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　而那些借助以太坊进行ICO的人，募集的并不是数字货币，它募集的就是一些加密货币。所以ICO也不能称之为数字货币。</p><p align="center" style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);"><img src="http://p0.ifengimg.com/pmop/2018/0605/A51D43AC985604E83F7B99804701CCBE14B62A045_size17_w468_h240.jpeg" alt="" width="468" height="240" border="0" style="padding:0px;border:none;"></p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　最重要的是，我们要充分认识到，区块链技术的魅力是要建立信任，而ICO乱象却是在摧毁信任。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　区块链的这种信任来源于什么，或者说信任是怎么建立起来的呢?</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　我们现在这个互联网时代，大家互相看不到对方的真身，有时我们在做价值交换的时候，很难信任对方，因为不公开嘛。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　但是，如果当一件事情大家都能够看得到的时候，那么它就不存在作假行为，也不存在作弊的可能性，对吧?这不就是说区块链技术嘛?</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　比如，一个人给我转十个比特币，我记账说他转给我一百个?但事实上大家都能看到这笔转账，你的100个比特币是虚假的，这样的话，这个记账人也许以后就要被大家淘汰了。而且在区块链这个平台上，这种检测成本是比较低的，所以大家就不会有做假账这个驱动力了。</p><p align="center" style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);"><img src="http://p0.ifengimg.com/pmop/2018/0605/AD07A128E7171E4AD7C13D790066B87D956217C81_size88_w1080_h606.jpeg" alt="" width="580" height="325" border="0" style="padding:0px;border:none;"></p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　优势与短板</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　刚刚讲了这么多，大家应该也感觉到区块链的优势所在。但是其实，区块链发展才不过几年，还处于一个“婴儿期”，它的“能”与“不能”同样明显。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　就拿信息保护来说吧。我们一直说区块链产生的信任来源于“公开”，但是公开就意味着没有秘密。比如，我给你转个账，但是我不希望任何人看到我给你转账，但是我又不能够作假，这其实也是挺尴尬的。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　更大的挑战则在技术之外，比如怎么实现真正的多方记账。现实情况是，许多场景中，参与者不愿意、没动力参与到这个分布式记帐本，一起记小本本。如何让大家接受区块链这个技术，参与进来，这还都需要考虑。</p><p align="center" style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);"><img src="http://p0.ifengimg.com/pmop/2018/0605/A77D084AEC5C031AB725206191831D1CD8145EAAD_size87_w1080_h607.jpeg" alt="" width="600" height="337" border="0" style="padding:0px;border:none;"></p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　但是，区块链的优势更显而易见。比如说，我们可以将区块链落地到公益领域，让每一笔善款都有迹可循。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　以前的公益善款记录，记小本本的就只是公益机构本人，他写什么你只能接受什么。但现在，有好几个小本本同时在记录这一件事情。我捐了100块钱，那就是实打实的100元，我还可以在区块链上看到每一笔资金的流向。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　所以你看，好多人同时记小本本，就是所谓的“去中心化”，他们之间可以相互作证，也相互证伪，因此最大程度上保证了透明性和信任度。</p><p align="center" style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);"><img src="http://p0.ifengimg.com/pmop/2018/0605/A2D2C8F92556F42E297428DF5763EF098124A62E9_size98_w1080_h596.jpeg" alt="" width="580" height="320" border="0" style="padding:0px;border:none;"></p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　除此之外，在保险行业、房屋租界行业、零售行业等等，区块链都可以凭借其“公开”的特性，大有所为。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　最后，我们不妨想象一下未来：我们捐出去的善款每一笔都清晰可查;我租的每一个房子房源清晰可见;母亲在挑奶粉时，不会再有 “这是不是真货”的犹疑……</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　那时，或许真的就没人再有兴趣问“区块链是什么?”了。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);text-align:right;">　　编辑/百里云鹤</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　最后有一个小福利。</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　在六一儿童节的时候，一位支付宝工程师给自己7岁的儿子画的一本童话故事书，主题是区块链……</p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);">　　如果你家也有小孩子对区块链感兴趣的话，不妨讲给他听。</p><p align="center" style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);"><img src="http://p0.ifengimg.com/pmop/2018/0605/A8BB3C5F98C2A3230023D384B3F5D1A73F8B08399_size531_w640_h8960.jpeg" alt="" width="640" height="1200" border="0" style="padding:0px;border:none;"></p><p style="margin-bottom:0px;padding-top:5px;padding-bottom:5px;line-height:28px;white-space:pre-wrap;color:rgb(0,0,0);font-family:Simsun;background-color:rgb(255,255,255);text-align:center;"><img src="http://www.szhgh.com/Article/news/society/2018-06-06/171932.html" width="250" style="padding:0px;border:none;" alt=""></p>                                    </div>
                    </div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%EF%BC%89/" data-id="cl1qb1dz1005lqktu4rlt3c2x" data-title="区块链详解（转）" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CUMTOJ数据结构实验内容3-4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/12/CUMTOJ%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B93-4/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T16:36:49.000Z" itemprop="datePublished">2019-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/12/CUMTOJ%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B93-4/">CUMTOJ数据结构实验内容3-4</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="问题-A-子网掩码"><a href="#问题-A-子网掩码" class="headerlink" title="问题 A: 子网掩码"></a>问题 A: 子网掩码</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>子网掩码是用来判断任意两台计算机的IP地址是否属于同一子网络的根据。<br>最为简单的理解就是两台计算机各自的IP地址与子网掩码进行AND运算后，如果得出的结果是相同的，则说明这两台计算机是处于同一个子网络上的，可以进行直接的通讯。就这么简单。</p>
<p>请看以下示例：</p>
<p>运算演示之一：<br>IP地址　   192.168.0.1<br>子网掩码　 255.255.255.0 </p>
<p>转化为二进制进行运算：<br>IP地址　  11010000.10101000.00000000.00000001<br>子网掩码　11111111.11111111.11111111.00000000 </p>
<p>AND运算：<br>　　　　　11010000.10101000.00000000.00000000 </p>
<p>转化为十进制后为：<br>　　　　　　192.168.0.0</p>
<p>运算演示之二：<br>IP地址　   192.168.0.254<br>子网掩码　 255.255.255.0 </p>
<p>转化为二进制进行运算：<br>IP地址　  11010000.10101000.00000000.11111110<br>子网掩码　11111111.11111111.11111111.00000000 </p>
<p>AND运算：<br>　　　　　11010000.10101000.00000000.00000000 </p>
<p>转化为十进制后为：<br>　　　　　　192.168.0.0</p>
<p>运算演示之三：<br>IP地址　   192.168.0.4<br>子网掩码　 255.255.255.0</p>
<p>转化为二进制进行运算：<br>IP地址　  11010000.10101000.00000000.00000100<br>子网掩码　11111111.11111111.11111111.00000000 </p>
<p>AND运算：<br>　　　　　11010000.10101000.00000000.00000000 </p>
<p>转化为十进制后为：<br>　　　　　　192.168.0.0</p>
<p>通过以上对三组计算机IP地址与子网掩码的AND运算后，我们可以看到它运算结果是一样的，均为192.168.0.0，所以计算机就会把这三台计算机视为在同一子网络。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行是本机IP地址；<br>第二行是子网掩码；<br>第三行是一个整数N，表示后面有N个IP地址；<br>接下来N行：<br>第1个IP地址<br>…<br>…<br>第N个IP地址</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>计算并输出N个IP地址是否与本机在同一子网内。对于在同一子网的输出“INNER”，对于在不同子网的输出“OUTER”。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>192.168.0.1<br>255.255.255.0<br>3<br>192.168.0.2<br>192.168.0.254<br>192.168.1.2</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>INNER<br>INNER<br>OUTER</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，利用scanf的特殊输入方式去除小数点，将输入的ip地址存储在数组中，然后，利用&amp;进行与操作，最后进行比较即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int local_ip[4] , subnet_mask[4] , test_ip[4];</span><br><span class="line">	int local_ip_subnet_mask[4] , test_ip_subnet_mask[4];</span><br><span class="line">	scanf(&quot;%d.%d.%d.%d&quot; , &amp;local_ip[0] , &amp;local_ip[1] , &amp;local_ip[2] , &amp;local_ip[3]);</span><br><span class="line">	scanf(&quot;%d.%d.%d.%d&quot; , &amp;subnet_mask[0] , &amp;subnet_mask[1] , &amp;subnet_mask[2] , &amp;subnet_mask[3]);</span><br><span class="line">	int i = 0;</span><br><span class="line">	while(i &lt; 4) &#123;</span><br><span class="line">		local_ip_subnet_mask[i] = local_ip[i] &amp; subnet_mask[i];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	int N;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	for(int j = 0;j &lt; N;j++) &#123;</span><br><span class="line">		scanf(&quot;%d.%d.%d.%d&quot; , &amp;test_ip[0] , &amp;test_ip[1] , &amp;test_ip[2] , &amp;test_ip[3]);</span><br><span class="line">		i = 0;</span><br><span class="line">		while(i &lt; 4) &#123;</span><br><span class="line">			test_ip_subnet_mask[i] = subnet_mask[i] &amp; test_ip[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		int k = 0;</span><br><span class="line">		for(i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">			if(test_ip_subnet_mask[i] != local_ip_subnet_mask[i]) &#123;</span><br><span class="line">				k = 1;</span><br><span class="line">				cout &lt;&lt; &quot;OUTER&quot; &lt;&lt; endl;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(!k)</span><br><span class="line">			cout &lt;&lt; &quot;INNER&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-B-快来秒杀我"><a href="#问题-B-快来秒杀我" class="headerlink" title="问题 B: 快来秒杀我"></a>问题 B: 快来秒杀我</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据前几次竞赛的情况，这次为了给新手们一点信心，特提供这道秒杀题来让大家杀。<br>ASCII码大家应该都学过了，现在给你一个很简单的任务，输入数字，表示ASCII码，输出对应的文本内容。</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行是一个整数T（1&lt;&#x3D;T&lt;&#x3D;100）。<br>接下来输入T个正整数，这些数之间用空格、换行或Tab键来分隔。<br>测试数据保证输入的整数都在ASCII码范围内，并且不小于32。</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>在一行中输出对应的文本内容。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>13<br>72 101 108 108 111 44<br>32 119 111 114 108 100 33</p>
</blockquote>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>Hello, world!</p>
</blockquote>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先，用source_num存储刚刚输入的数字，然后，立即强制将其转化成字符形式即可</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T = 0 , source_num;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	int tmp = 0;</span><br><span class="line">	for(; tmp &lt; T; tmp++) &#123;</span><br><span class="line">		cin &gt;&gt; source_num;</span><br><span class="line">		cout &lt;&lt; (char)(source_num);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-C-最短路径1"><a href="#问题-C-最短路径1" class="headerlink" title="问题 C: 最短路径1"></a>问题 C: 最短路径1</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>有n个城市m条道路（n&lt;1000, m&lt;10000），每条道路有个长度，请找到从起点s到终点t的最短距离和经过的城市名。</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>输入包含多组测试数据。</p>
<p>每组第一行输入四个数，分别为n，m，s，t。</p>
<p>接下来m行，每行三个数，分别为两个城市名和距离。</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>每组输出占两行。</p>
<p>第一行输出起点到终点的最短距离。</p>
<p>第二行输出最短路径上经过的城市名，如果有多条最短路径，输出字典序最小的那条。若不存在从起点到终点的路径，则输出“can’t arrive”。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>3 3 1 3<br>1 3 3<br>1 2 1<br>2 3 1</p>
</blockquote>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>2<br>1 2 3</p>
</blockquote>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>首先，利用while循环输入n m s t，然后，利用一个队列存储城市名及其间距，最后利用Dijkstra算法求出最短路径</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cfloat&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">const int INF = 1000000;</span><br><span class="line">const int max_num = 1010;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node &#123;</span><br><span class="line">    int w;</span><br><span class="line">    int v;</span><br><span class="line">    node(int a , int b) : v(a) , w(b) &#123;  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">int des[max_num] , pre[max_num];</span><br><span class="line">vector&lt;node&gt; G[max_num];</span><br><span class="line">bool visited[max_num];</span><br><span class="line">int N;</span><br><span class="line">void Dijkstra(int s) &#123;</span><br><span class="line">    fill(des , des + N + 1 , INF);</span><br><span class="line">    for (int i = 0; i &lt; N; i++)</span><br><span class="line">		pre[i] = i;</span><br><span class="line">    memset(visited , 0 , N + 1);</span><br><span class="line">    des[s] = 0;</span><br><span class="line">    for (int i = 1 , Min , u; i &lt;= N; i++) &#123;</span><br><span class="line">        Min = INF;</span><br><span class="line">		u = -1;</span><br><span class="line">        for (int k = 1; k &lt;= N; k++) &#123;</span><br><span class="line">            if (!visited[k] &amp;&amp; Min &gt; des[k]) &#123;</span><br><span class="line">                Min = des[k];</span><br><span class="line">                u = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (u == -1)</span><br><span class="line">			return;</span><br><span class="line">        visited[u] = true;</span><br><span class="line">        for (int k = 0; k &lt; G[u].size(); k++) &#123;</span><br><span class="line">            int v = G[u][k].v;</span><br><span class="line">            if(!visited[v]) &#123;</span><br><span class="line">                if (des[v] &gt; des[u] + G[u][k].w) &#123;</span><br><span class="line">                    des[v] = des[u] + G[u][k].w;</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (des[v] == des[u] + G[u][k].w &amp;&amp; pre[v] &gt; u)</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int s , int e) &#123;</span><br><span class="line">    if (s == e) &#123;</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(s , pre[e]);</span><br><span class="line">    cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    #ifdef _DEBUG</span><br><span class="line">    freopen(&quot;data.txt&quot;, &quot;r+&quot;, stdin);</span><br><span class="line">	#endif // _DEBUG</span><br><span class="line">    std::ios::sync_with_stdio(false);</span><br><span class="line">    int M , s , t;</span><br><span class="line">    while(cin &gt;&gt; N &gt;&gt; M &gt;&gt; s &gt;&gt; t) &#123;</span><br><span class="line">        for (int i = 1; i &lt;= N; i++)</span><br><span class="line">            G[i].clear();</span><br><span class="line">        for (int i = 0, d = 1; i &lt; M; i++ , d *= 2) &#123;</span><br><span class="line">            int u , v , w;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            G[u].push_back(node(v , w));</span><br><span class="line">            G[v].push_back(node(u , w));</span><br><span class="line">        &#125;</span><br><span class="line">        Dijkstra(s);</span><br><span class="line">        if (des[t] != INF) &#123;</span><br><span class="line">            cout &lt;&lt; des[t] &lt;&lt; endl;</span><br><span class="line">            DFS(s, t);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;can&#x27;t arrive&quot;;</span><br><span class="line">       cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-D-二叉排序树"><a href="#问题-D-二叉排序树" class="headerlink" title="问题 D: 二叉排序树"></a>问题 D: 二叉排序树</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一系列整数，建立二叉排序数，并进行前序，中序，后序遍历。</p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入第一行包括一个整数n(1&lt;&#x3D;n&lt;&#x3D;100)。接下来的一行包括n个整数。</p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>可能有多组测试数据，对于每组数据，将题目所给数据建立一个二叉排序树，并对二叉排序树进行前序、中序和后序遍历。每种遍历结果输出一行。每行最后一个数据之后有一个空格。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>1<br>2<br>2<br>8 15<br>4<br>21 10 5 39 </p>
</blockquote>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>2<br>2<br>2<br>8 15<br>8 15<br>15 8<br>21 10 5 39<br>5 10 21 39<br>5 10 39 21 </p>
</blockquote>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先，将输入的数据建立一棵二叉排序树，然后，进行前序、中序、后序遍历即可</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int data;</span><br><span class="line">	node *left , *right;</span><br><span class="line">&#125;;</span><br><span class="line">void insert(node* &amp;root , int x) &#123;</span><br><span class="line">	if (root == NULL) &#123;</span><br><span class="line">		root = new node;</span><br><span class="line">		root-&gt;data = x;</span><br><span class="line">		root-&gt;left = root-&gt;right = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (x == root-&gt;data) </span><br><span class="line">		return;</span><br><span class="line">	else if (x &lt; root-&gt;data)</span><br><span class="line">		insert(root-&gt;left , x);</span><br><span class="line">	else</span><br><span class="line">		insert(root-&gt;right , x);</span><br><span class="line">&#125;</span><br><span class="line">void preorder(node* root) &#123;</span><br><span class="line">	if (root == NULL)</span><br><span class="line">		return;</span><br><span class="line">	cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">	preorder(root-&gt;left);</span><br><span class="line">	preorder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">void inorder(node* root) &#123;</span><br><span class="line">	if (root == NULL)</span><br><span class="line">		return;</span><br><span class="line">	inorder(root-&gt;left);</span><br><span class="line">	cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">	inorder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">void postorder(node* root) &#123;</span><br><span class="line">	if (root == NULL)</span><br><span class="line">		return;</span><br><span class="line">	postorder(root-&gt;left);</span><br><span class="line">	postorder(root-&gt;right);</span><br><span class="line">	cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n , x;</span><br><span class="line">	while (cin &gt;&gt; n) &#123;</span><br><span class="line">		node *root = NULL;</span><br><span class="line">		for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			insert(root , x);</span><br><span class="line">		&#125;</span><br><span class="line">		preorder(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		inorder(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		postorder(root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识延伸"><a href="#知识延伸" class="headerlink" title="知识延伸"></a>知识延伸</h2><ol>
<li>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有节点的值均小于它的根节点的值；<br>（2）若右子树不空，则右子树上所有节点的值均大于它的根节点的值；<br>（3）左、右子树也分别为二叉排序树；<br>（4）没有键值相等的节点。</li>
<li>前序、中序、后序</li>
</ol>
<ul>
<li><p>前序遍历（根–&gt;左–&gt;右）</p>
<pre><code>  (1) 访问根节点 

  (2) 前序遍历左子树 

  (3) 前序遍历右子树
</code></pre>
</li>
<li><p>中序遍历（左–&gt;根–&gt;右）</p>
<pre><code>  (1)中序遍历左子树

  (2) 访问根节点

  (3) 中序遍历右子树
</code></pre>
</li>
<li><p>后序遍历（左–&gt;右–&gt;根）</p>
<pre><code>  (1) 后序遍历左子树

  (2) 后序遍历右子树

  (3) 访问根节点
</code></pre>
</li>
</ul>
<h1 id="问题-E-密码锁"><a href="#问题-E-密码锁" class="headerlink" title="问题 E: 密码锁"></a>问题 E: 密码锁</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>玛雅人有一种密码，如果字符串中出现连续的2012四个数字就能解开密码。给一个长度为N的字符串，（2&#x3D;&lt;N&lt;&#x3D;13）该字符串中只含有0,1,2三种数字，问这个字符串要移位几次才能解开密码，每次只能移动相邻的两个数字。例如02120经过一次移位，可以得到20120,01220,02210,02102，其中20120符合要求，因此输出为1.如果无论移位多少次都解不开密码，输出-1。</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>第一行输入N，第二行输入N个数字，只包含0，1，2</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>02120</p>
</blockquote>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1</p>
</blockquote>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>首先，利用一个双端队列record记录输入的输入的012字符串，然后，比较即可</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string str;</span><br><span class="line">int N;</span><br><span class="line">bool visited[1600000];</span><br><span class="line">int main() &#123;</span><br><span class="line">	bool match(const string &amp;str1);</span><br><span class="line">	int hash_func(string cur);</span><br><span class="line">    while(scanf(&quot;%d&quot; , &amp;N) != EOF) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        memset(visited , 0 , sizeof(visited));</span><br><span class="line">        deque&lt;string&gt; record;</span><br><span class="line">        record.push_back(str);</span><br><span class="line">        int cur_lel = 1 , nxt_lel = 0 , ret = 0;</span><br><span class="line">        bool found = false;</span><br><span class="line">        while(!record.empty()) &#123;</span><br><span class="line">            string cur = record.front();</span><br><span class="line">            record.pop_front();</span><br><span class="line">            cur_lel --;</span><br><span class="line">            if(match(cur)) &#123;</span><br><span class="line">                found = true;</span><br><span class="line">                cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i = 0; i &lt; N - 1; i ++) &#123;</span><br><span class="line">                swap(cur[i] , cur[i+1]);</span><br><span class="line">                int hash_val = hash_func(cur);</span><br><span class="line">                if(!visited[hash_val]) &#123;</span><br><span class="line">                    visited[hash_val] = true;</span><br><span class="line">                    record.push_back(cur);</span><br><span class="line">                    nxt_lel ++;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(cur[i] , cur[i+1]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(cur_lel == 0) &#123;</span><br><span class="line">                cur_lel = nxt_lel;</span><br><span class="line">                nxt_lel = 0;</span><br><span class="line">                ret ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!found)</span><br><span class="line">            cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">bool match(const string &amp;str1) &#123;</span><br><span class="line">    for(int i = 0; i &lt;= N - 4; i ++) &#123;</span><br><span class="line">        if(str1.substr(i, 4) == &quot;2012&quot;)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int hash_func(string cur) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int i = 0; i &lt; N; i ++)</span><br><span class="line">        res = res * 3 + cur[i] - &#x27;0&#x27;;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识延伸-1"><a href="#知识延伸-1" class="headerlink" title="知识延伸"></a>知识延伸</h2><ol>
<li>string类的使用<br>string的子串：<br>string substr(int pos &#x3D; 0,int n &#x3D; npos) const;&#x2F;&#x2F;返回pos开始的n个字符组成的字符串<br>string的交换：<br>void swap(string &amp;s2);    &#x2F;&#x2F;交换当前字符串与s2的值</li>
<li>memset的使用<br>函数原型：void *memset(void *s , int ch , size_t  n )<br>函数解释：将s中的前n个字节用ch替换并且返回s<br>函数作用：在一段内存块中填充某一个给定的值，常用于较大的对结构体和数组的清零操作。</li>
<li>deque<br>void push_front(const T&amp; x):双端队列头部增加一个元素x<br>void push_back(const T&amp; x):双端队列尾部增加一个元素x<br>void pop_front():删除双端队列中最前一个元素<br>void pop_back():删除双端队列中最后一个元素<br>void clear():清空双端队列中最后一个元素<br>void swap(deque&amp;):交换两个同类型向量的数据</li>
</ol>
<h1 id="问题-F-算法10-6-10-8：快速排序"><a href="#问题-F-算法10-6-10-8：快速排序" class="headerlink" title="问题 F: 算法10-6~10-8：快速排序"></a>问题 F: 算法10-6~10-8：快速排序</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>快速排序是对起泡排序的一种改进。它的基本思想是，通过一趟排序将待排序的记录分割成两个独立的部分，其中一部分记录的关键字均比另一部分的关键字小，在分成两个部分之后则可以分别对这两个部分继续进行排序，从而使整个序列有序。<br>快速排序的算法可以描述如下：<br><img src="https://img-blog.csdnimg.cn/2019092116070650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"><br>在本题中，读入一串整数，将其使用以上描述的快速排序的方法从小到大排序，并输出。</p>
<h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行包含1个正整数n，表示共有n个整数需要参与排序。其中n不超过100000。<br>第二行包含n个用空格隔开的正整数，表示n个需要排序的整数。</p>
<h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>只有1行，包含n个整数，表示从小到大排序完毕的所有整数。<br>请在每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10<br>2 8 4 6 1 10 7 3 5 9</p>
</blockquote>
<h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1 2 3 4 5 6 7 8 9 10 </p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>在本题中，需要按照题目描述中的算法完成快速排序的算法。</p>
<p>快速排序是一种十分常用的排序算法，其平均时间复杂度为O(knlnn)，其中n为待排序序列中记录的个数，k为常数。大量的实际应用证明，在所有同数量级的此类排序算法中，快速排序的常数因子k是最小的，因此，就平均时间而言，快速排序是目前被认为最好的一种内部排序方法。</p>
<p>而在C语言的常用编译器中，qsort函数是一个非常常用的快速排序函数。</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>首先，利用一个大数组存储输入的待排序数字，然后，利用qsort函数进行处理，最后，输出即可。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int cmp(const void *a , const void *b);</span><br><span class="line">	int arr[100000];</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot; , &amp;n);</span><br><span class="line">	int tmp;</span><br><span class="line">	for(tmp = 0; tmp &lt; n; tmp++)</span><br><span class="line">		scanf(&quot;%d&quot; , &amp;arr[tmp]);</span><br><span class="line">	qsort(arr , n , sizeof(arr[0]) , cmp);</span><br><span class="line">	for(tmp = 0; tmp &lt; n - 1; tmp++)</span><br><span class="line">		printf(&quot;%d &quot; , arr[tmp]);</span><br><span class="line">	printf(&quot;%d\n&quot; , arr[tmp]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int cmp(const void *a , const void *b) &#123;</span><br><span class="line">  return *(int *)a - *(int *)b; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="知识延伸-2"><a href="#知识延伸-2" class="headerlink" title="知识延伸"></a>知识延伸</h2><p>qsort函数包含在&lt;stdlib.h&gt;中</p>
<p>qsort函数声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void qsort(void * base,size_t nmemb,size_t size ,int(*compar)(const void *,const void *));</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>base,要排序的数组<br>nmemb,数组中元素的数目<br>size,每个数组元素占用的内存空间，可使用sizeof函数获得</p>
<h1 id="问题-G-算法10-2：折半插入排序"><a href="#问题-G-算法10-2：折半插入排序" class="headerlink" title="问题 G: 算法10-2：折半插入排序"></a>问题 G: 算法10-2：折半插入排序</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>折半插入排序同样是一种非常简单的排序方法，它的基本操作是在一个已经排好序的有序表中进行查找和插入。不难发现这个查找的过程可以十分自然的修改成折半查找的方式进行实现。<br>折半插入排序的算法可以描述如下：<br><img src="https://img-blog.csdnimg.cn/20190921162838113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"><br>在本题中，读入一串整数，将其使用以上描述的折半插入排序的方法从小到大排序，并输出。</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行包含1个正整数n，表示共有n个整数需要参与排序。其中n不超过1000。<br>第二行包含n个用空格隔开的正整数，表示n个需要排序的整数。</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>只有1行，包含n个整数，表示从小到大排序完毕的所有整数。<br>请在每个整数后输出一个空格，并请注意行尾输出换行。</p>
<h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10<br>2 8 4 6 1 10 7 3 5 9</p>
</blockquote>
<h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1 2 3 4 5 6 7 8 9 10 </p>
</blockquote>
<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>在本题中，需要按照题目描述中的算法完成折半插入排序的算法。与直接插入排序算法不同，折半插入排序算法在查找插入位置时采用了折半查找的方案，减少了关键字之间的比较次数，但是记录的移动次数并没有发生改变，因此折半插入排序的时间复杂度依旧为O(n2)，同样不是一种非常高效的排序方法。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>首先，利用一个大数组arr存储输入的待排序数字，然后，调用BInsertSort函数进行处理，最后，输出即可。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int arr[1000] , n;</span><br><span class="line">int main() &#123;</span><br><span class="line">	void BInsertSort();</span><br><span class="line"> 	while(cin &gt;&gt; n) &#123;</span><br><span class="line"> 		for(int i = 0; i &lt; n; i++)</span><br><span class="line"> 			cin &gt;&gt; arr[i];</span><br><span class="line"> 		BInsertSort();</span><br><span class="line"> 		for(int i = 0; i &lt; n; i++)</span><br><span class="line"> 			cout&lt;&lt; arr[i] &lt;&lt;&quot; &quot;;</span><br><span class="line"> 		cout &lt;&lt; endl;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br><span class="line">void BInsertSort() &#123;</span><br><span class="line">	for(int i = 1; i &lt; n; i++) &#123;</span><br><span class="line"> 		int low = 0 , high = i - 1 , mid;</span><br><span class="line"> 		while(low &lt;= high) &#123;</span><br><span class="line"> 			mid = (low + high) / 2;</span><br><span class="line">	 		if(arr[mid] &gt;= arr[i])</span><br><span class="line">	  			high = mid - 1;</span><br><span class="line">	 		else</span><br><span class="line">	  			low = mid + 1;	</span><br><span class="line">		&#125;</span><br><span class="line">		int temp = arr[i];</span><br><span class="line">		for(int j = i; j &gt; low; j--)</span><br><span class="line">	 		arr[j] = arr[j - 1];</span><br><span class="line">		arr[low] = temp;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-H-算法7-9：最小生成树"><a href="#问题-H-算法7-9：最小生成树" class="headerlink" title="问题 H: 算法7-9：最小生成树"></a>问题 H: 算法7-9：最小生成树</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>最小生成树问题是实际生产生活中十分重要的一类问题。假设需要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。这时，自然需要考虑这样一个问题，即如何在最节省经费的前提下建立这个通信网。<br>可以用连通网来表示n个城市以及n个城市之间可能设置的通信线路，其中网的顶点表示城市，边表示两个城市之间的线路，赋于边的权值表示相应的代价。对于n个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是一个通信网。现在，需要选择一棵生成树，使总的耗费最小。这个问题就是构造连通网的最小代价生成树，简称最小生成树。一棵生成树的代价就是树上各边的代价之和。<br>而在常用的最小生成树构造算法中，普里姆（Prim）算法是一种非常常用的算法。以下是其算法的大致结构：<br><img src="https://img-blog.csdnimg.cn/20190921164333252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"><br>在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立最小生成树，并输出最小生成树的代价。</p>
<h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。<br>以后的n行中每行有n个用空格隔开的整数，对于第i行的第j个整数，如果不为0，则表示第i个顶点和第j个顶点有直接连接且代价为相应的值，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。<br>输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图，且保证图中只有一个连通分量。</p>
<h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>只有一个整数，即最小生成树的总代价。请注意行尾输出换行。</p>
<h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>4<br>0 2 4 0<br>2 0 3 5<br>4 3 0 1<br>0 5 1 0</p>
</blockquote>
<h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>6</p>
</blockquote>
<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>在本题中，需要掌握图的深度优先遍历的方法，并需要掌握无向图的连通性问题的本质。通过求出无向图的连通分量和对应的生成树，应该能够对图的连通性建立更加直观和清晰的概念。</p>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>首先，利用GetM()函数将邻接矩阵输入并存储在Arrow结构体中，然后，调用MiniSpanTree()函数生成最小生成树，最后，运算并输出最小生成树的代价。</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXLEN 100</span><br><span class="line">int Flag[MAXLEN] = &#123;0&#125;;</span><br><span class="line">int flag;</span><br><span class="line">int N;</span><br><span class="line">int Count;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int len;</span><br><span class="line">	int NodeA;</span><br><span class="line">	int NodeB;</span><br><span class="line">&#125; arrow;</span><br><span class="line">arrow Arrow[MAXLEN * MAXLEN];</span><br><span class="line">int main() &#123;</span><br><span class="line">	void GetM();</span><br><span class="line">	void MiniSpanTree(); </span><br><span class="line">    GetM();</span><br><span class="line">	MiniSpanTree();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">void GetM() &#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	int temp;</span><br><span class="line">	Count = 0;</span><br><span class="line">	for(int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">	    for(int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">		     cin &gt;&gt; temp;</span><br><span class="line">			 if(temp != 0 &amp;&amp; i &gt;= j) &#123;</span><br><span class="line">			     Arrow[Count].len = temp;</span><br><span class="line">				 Arrow[Count].NodeA = i;</span><br><span class="line">				 Arrow[Count].NodeB = j;</span><br><span class="line">				 Count++;</span><br><span class="line">			 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void MiniSpanTree() &#123;</span><br><span class="line">    arrow Temp;</span><br><span class="line">	int LenNum = 0;</span><br><span class="line">	int Sum = 0;</span><br><span class="line">	int i;</span><br><span class="line">	for(i = 0; i &lt; Count; i++) &#123;</span><br><span class="line">	    for(int j = i; j &lt; Count; j++) &#123;</span><br><span class="line">		    if(Arrow[i].len &gt; Arrow[j].len) &#123;</span><br><span class="line">				Temp.len = Arrow[i].len;</span><br><span class="line">				Temp.NodeA = Arrow[i].NodeA;</span><br><span class="line">				Temp.NodeB = Arrow[i].NodeB;</span><br><span class="line">				Arrow[i].len = Arrow[j].len;</span><br><span class="line">				Arrow[i].NodeA = Arrow[j].NodeA;</span><br><span class="line">				Arrow[i].NodeB = Arrow[j].NodeB;</span><br><span class="line">				Arrow[j].len = Temp.len;</span><br><span class="line">				Arrow[j].NodeA = Temp.NodeA;</span><br><span class="line">				Arrow[j].NodeB = Temp.NodeB;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    flag = 0;</span><br><span class="line">    int a , b;</span><br><span class="line">	for(int i = 0; i &lt; Count &amp;&amp; LenNum &lt; N - 1; i++) &#123;</span><br><span class="line">        a = Arrow[i].NodeA;</span><br><span class="line">        b = Arrow[i].NodeB;</span><br><span class="line">        if(Flag[a] == 0 &amp;&amp; Flag[b] == 0) &#123;</span><br><span class="line">                Sum += Arrow[i].len;</span><br><span class="line">                LenNum++;</span><br><span class="line">                flag++;</span><br><span class="line">                Flag[a] = flag;</span><br><span class="line">                Flag[b] = flag;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(Flag[a] == 0 &amp;&amp; Flag[b] != 0) &#123;</span><br><span class="line">            Sum += Arrow[i].len;</span><br><span class="line">            LenNum++;</span><br><span class="line">            Flag[a] = Flag[b];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(Flag[a] != 0 &amp;&amp; Flag[b] == 0) &#123;</span><br><span class="line">            Sum += Arrow[i].len;</span><br><span class="line">            LenNum++;</span><br><span class="line">            Flag[b] = Flag[a];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(Flag[a] != 0 &amp;&amp; Flag[b] != 0 &amp;&amp; Flag[a] != Flag[b]) &#123;</span><br><span class="line">            Sum += Arrow[i].len;</span><br><span class="line">            LenNum++;</span><br><span class="line">            int t = Flag[b];</span><br><span class="line">            Flag[b] = Flag[a];</span><br><span class="line">            for(int j = 0; j &lt; N; j++) &#123;</span><br><span class="line">                if(Flag[j] == t)</span><br><span class="line">                    Flag[j] = Flag[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	cout &lt;&lt; Sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-I-8-5-11-Disk-Tree"><a href="#问题-I-8-5-11-Disk-Tree" class="headerlink" title="问题 I: 8.5.11 Disk Tree"></a>问题 I: 8.5.11 Disk Tree</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>Hacker Bill has accidentally lost all the information from his workstation’s hard drive and he has no backup copies of its contents. He does not regret for the loss of the files themselves, but for the very nice and convenient directory structure that he had created and cherished during years of work. Fortunately, Bill has several copies of directory listings from his hard drive. Using those listings he was able to recover full paths (like “WINNT\SYSTEM32\CERTSRV\CERTCO~1\X86”) for some directories. He put all of them in a file by writing each path he has found on a separate line. Your task is to write a program that will help Bill to restore his state of the art directory structure by providing nicely formatted directory tree.</p>
<h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>The first line of the input file contains single integer number N (1 &lt;&#x3D; N &lt;&#x3D; 500) that denotes a total number of distinct directory paths. Then N lines with directory paths follow. Each directory path occupies a single line and does not contain any spaces, including leading or trailing ones. No path exceeds 80 characters. Each path is listed once and consists of a number of directory names separated by a back slash (“&quot;). </p>
<p>Each directory name consists of 1 to 8 uppercase letters, numbers, or the special characters from the following list: exclamation mark, number sign, dollar sign, percent sign, ampersand, apostrophe, opening and closing parenthesis, hyphen sign, commercial at, circumflex accent, underscore, grave accent, opening and closing curly bracket, and tilde (“!#$%&amp;’()-@^_&#96;{}~”). </p>
<h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>Write to the output file the formatted directory tree. Each directory name shall be listed on its own line preceded by a number of spaces that indicate its depth in the directory hierarchy. The subdirectories shall be listed in lexicographic order immediately after their parent directories preceded by one more space than their parent directory. Top level directories shall have no spaces printed before their names and shall be listed in lexicographic order. See sample below for clarification of the output format.</p>
<h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>7<br>WINNT\SYSTEM32\CONFIG<br>GAMES<br>WINNT\DRIVERS<br>HOME<br>WIN\SOFT<br>GAMES\DRIVERS<br>WINNT\SYSTEM32\CERTSRV\CERTCO~1\X86</p>
</blockquote>
<h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>GAMES<br>DRIVERS<br>HOME<br>WIN<br>SOFT<br>WINNT<br>DRIVERS<br>SYSTEM32<br>CERTSRV<br>CERTCO~1<br>X86<br>CONFIG</p>
</blockquote>
<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXNODE 20000</span><br><span class="line">#define MAXLEN 85</span><br><span class="line">#define MAXWORD 45</span><br><span class="line">map&lt;string , int&gt; m[MAXNODE];</span><br><span class="line">void preOder_traversal(int midx , int indentation) &#123;</span><br><span class="line">	for (map&lt;string , int&gt;::iterator i = m[midx].begin(); i != m[midx].end(); ++i) &#123;</span><br><span class="line">		for (int i = 0; i &lt; indentation; ++i)</span><br><span class="line">			printf(&quot; &quot;);</span><br><span class="line">		printf(&quot;%s\n&quot; , (i-&gt;first).c_str());</span><br><span class="line">		preOder_traversal(i-&gt;second , indentation+1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n , i , j , midx , midx_counter = 0;</span><br><span class="line">	char str[MAXLEN];</span><br><span class="line">	int word_init[MAXWORD];</span><br><span class="line">	string current_str;</span><br><span class="line">	scanf(&quot;%d&quot; , &amp;n);</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		scanf(&quot;%s&quot;, str);</span><br><span class="line">		word_init[0] = 0;</span><br><span class="line">		j = 1;</span><br><span class="line">		for (i = 0; str[i]; ++i) &#123;</span><br><span class="line">			if(str[i] == &#x27;\\&#x27;) &#123;</span><br><span class="line">				str[i] = 0;</span><br><span class="line">				word_init[j++] = i + 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		midx = 0;</span><br><span class="line">		for (i = 0; i &lt; j; ++i) &#123;</span><br><span class="line">			current_str = str + word_init[i];</span><br><span class="line">			if(!m[midx].count(current_str))</span><br><span class="line">				m[midx][current_str] = (++midx_counter);</span><br><span class="line">			midx = m[midx][current_str];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	preOder_traversal(0 , 0);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/12/CUMTOJ%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B93-4/" data-id="cl1qb1dxc0013qktubk984vf2" data-title="CUMTOJ数据结构实验内容3-4" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript学习记录1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/12/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T16:13:06.000Z" itemprop="datePublished">2019-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/12/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/">JavaScript学习记录1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>最近在学习JavaScript，今天学到了下面的内容，做个回顾吧。</p>
<p>作用域、作用域链精解、立即执行函数、闭包、闭包精细版</p>
<h1 id="2-学习内容"><a href="#2-学习内容" class="headerlink" title="2 学习内容"></a>2 学习内容</h1><h2 id="2-1-作用域、作用域链精解基本概念"><a href="#2-1-作用域、作用域链精解基本概念" class="headerlink" title="2.1 作用域、作用域链精解基本概念"></a>2.1 作用域、作用域链精解基本概念</h2><ol>
<li>运行期上下文<br>当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文被销毁。</li>
<li>查找变量<br>从作用域链的顶端依次向下查找</li>
<li>[[scope]]<br>每个JavaScript函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供JavaScript引擎存取，[[scope]]就是其中一个。<br>[[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。</li>
<li>作用域链<br>[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫作用域链。</li>
</ol>
<h3 id="2-1-1-示例"><a href="#2-1-1-示例" class="headerlink" title="2.1.1 示例"></a>2.1.1 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    function b() &#123;</span><br><span class="line">    	var b = 234;</span><br><span class="line">    &#125;</span><br><span class="line">    var a = 123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">var glob = 100;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-函数作用域链详解："><a href="#2-1-2-函数作用域链详解：" class="headerlink" title="2.1.2 函数作用域链详解："></a>2.1.2 函数作用域链详解：</h3><p><img src="https://img-blog.csdnimg.cn/20190922003117957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20190922003206199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20190922003227231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20190922003248753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<h2 id="2-2-立即执行函数"><a href="#2-2-立即执行函数" class="headerlink" title="2.2 立即执行函数"></a>2.2 立即执行函数</h2><h3 id="2-2-功能："><a href="#2-2-功能：" class="headerlink" title="2.2 功能："></a>2.2 功能：</h3><p>此类函数没有声明，在一次执行过后即释放，适合做初始化工作。<br>实例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">    var b = 2;</span><br><span class="line">    console.log(a + b);</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190922113015135.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (a , b , c) &#123;</span><br><span class="line">    console.log(a + b + c * 2);</span><br><span class="line">&#125;(1 , 2 , 3))</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190922112953728.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var result = (function (a , b , c) &#123;</span><br><span class="line">    var d = a + b * 2 + c * a;</span><br><span class="line">    return d</span><br><span class="line">&#125;(1 , 2 , 3))</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190922113215203.png"></p>
<p>两种常用写法</p>
<p>(function() {} () );  W3C建议使用第一种<br>(function() {} ) ();</p>
<p>阿里巴巴曾经的一个考试题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test(a , b , c , d) &#123;</span><br><span class="line">    console.log( a + b + c + d);</span><br><span class="line">&#125;(1 , 2 , 3 , 4);</span><br></pre></td></tr></table></figure>

<p>上面的代码就相当于下面的代码，讲函数test()的声明与(1 , 2 , 3 , 4);分开执行，但不报错也不输出任何的东西</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test(a , b , c , d) &#123;</span><br><span class="line">    console.log( a + b + c + d);</span><br><span class="line">&#125;</span><br><span class="line">(1 , 2 , 3 , 4);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190922114711704.png"></p>
<h2 id="2-3-闭包"><a href="#2-3-闭包" class="headerlink" title="2.3 闭包"></a>2.3 闭包</h2><h3 id="2-3-1-基本概念"><a href="#2-3-1-基本概念" class="headerlink" title="2.3.1 基本概念"></a>2.3.1 基本概念</h3><p>闭包：当函数内部被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    function b() &#123;</span><br><span class="line">    	var bb = 234;</span><br><span class="line">    	aa++;</span><br><span class="line">    	console.log(aa);</span><br><span class="line">    &#125;</span><br><span class="line">    var aa = 123;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">var glob = 100;</span><br><span class="line">var demo = a();</span><br><span class="line">demo();</span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>

<p>代码执行期上下文过程</p>
<p><img src="https://img-blog.csdnimg.cn/20190922105257510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<p>函数a返回的是b的引用</p>
<p><img src="https://img-blog.csdnimg.cn/20190922105629615.png"></p>
<h3 id="2-3-2-作用"><a href="#2-3-2-作用" class="headerlink" title="2.3.2 作用"></a>2.3.2 作用</h3><h4 id="2-3-2-1-实现共有变量（函数累加器）"><a href="#2-3-2-1-实现共有变量（函数累加器）" class="headerlink" title="2.3.2.1 实现共有变量（函数累加器）"></a>2.3.2.1 实现共有变量（函数累加器）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">    var count = 123;</span><br><span class="line">    function demo() &#123;</span><br><span class="line">    	count++;</span><br><span class="line">    	console.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    return demo;</span><br><span class="line">&#125;</span><br><span class="line">var counter = add();</span><br><span class="line">counter();</span><br><span class="line">counter();</span><br><span class="line">counter();</span><br><span class="line">counter();</span><br><span class="line">counter();</span><br><span class="line">counter();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190922110142776.png"></p>
<h4 id="2-3-2-2-可以做缓存（存储结构）"><a href="#2-3-2-2-可以做缓存（存储结构）" class="headerlink" title="2.3.2.2 可以做缓存（存储结构）"></a>2.3.2.2 可以做缓存（存储结构）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function eater() &#123;</span><br><span class="line">    var food = &quot;&quot;;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">    	eat : function () &#123;</span><br><span class="line">    		console.log( &quot;I am eating &quot; + food);</span><br><span class="line">			food = &quot;&quot;;</span><br><span class="line">    	&#125;,</span><br><span class="line">    	push: function (myFood) &#123;</span><br><span class="line">			food = &quot;myFood&quot;;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">var eater1 = eater();</span><br><span class="line">eater1.push(&quot;banana&quot;);</span><br><span class="line">eater1.eat();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190922111815236.png"></p>
<h4 id="2-3-2-3-可以实现封装，属性私有化"><a href="#2-3-2-3-可以实现封装，属性私有化" class="headerlink" title="2.3.2.3 可以实现封装，属性私有化"></a>2.3.2.3 可以实现封装，属性私有化</h4><h4 id="2-3-2-4-模块化开发，防止污染全局变量"><a href="#2-3-2-4-模块化开发，防止污染全局变量" class="headerlink" title="2.3.2.4 模块化开发，防止污染全局变量"></a>2.3.2.4 模块化开发，防止污染全局变量</h4><h3 id="2-3-3-详解"><a href="#2-3-3-详解" class="headerlink" title="2.3.3 详解"></a>2.3.3 详解</h3><p>经典代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    	arr[i] = function () &#123;</span><br><span class="line">    		document.write(i + &quot; &quot;);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var myArr = test();</span><br><span class="line">for(var j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">    myArr[j]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码执行结果</p>
<p><img src="https://img-blog.csdnimg.cn/20190922120518673.png"></p>
<p>代码执行过程，test()函数中的arr[i] &#x3D; function() {}执行时并不执行function中的代码，只是传了一个引用值给arr[i]，等到真正执行的时候才会回来看function中的代码并执行<br>要解决上述矛盾，必须使用立即执行函数，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    	(function (j) &#123;</span><br><span class="line">    		arr[j] = function () &#123;</span><br><span class="line">    			document.write(j + &quot; &quot;);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var myArr = test();</span><br><span class="line">for(var j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">    myArr[j]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-基本规律"><a href="#2-3-4-基本规律" class="headerlink" title="2.3.4 基本规律"></a>2.3.4 基本规律</h3><p>只有表达式才能被执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码称为函数声明，不是表达式，后面加()后会爆出低级语法错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function() &#123;&#125; ();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190922143910127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<p>而下面的代码会正常执行，相当于var demo &#x3D; function ()<br>{console.log(“hello”);}是一个表达式，运行完一次之后就不能再运行了，相当于立即执行函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var demo = function () &#123;</span><br><span class="line">    console.log(&quot;hello&quot;);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190922144019137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<p>再函数声明前面加上 + - ! 后面加()都能将其变成函数表达式，也类似于立即执行函数，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ function test() &#123;</span><br><span class="line">    console.log(&quot;hello&quot;);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">- function test() &#123;</span><br><span class="line">    console.log(&quot;hello&quot;);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">! function test() &#123;</span><br><span class="line">    console.log(&quot;hello&quot;);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">![](https://img-blog.csdnimg.cn/2019092214481018.png)</span><br></pre></td></tr></table></figure>

<p>阿里曾经一道笔试题<br>使用原生js，addEventListener，给每个li元素绑定一个click事件，输出它们的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;demo&lt;/title&gt;</span><br><span class="line">	&lt;style&gt;</span><br><span class="line">		*&#123;</span><br><span class="line">			margin : 0;</span><br><span class="line">			padding : 0;</span><br><span class="line">		&#125;</span><br><span class="line">		ul &#123;</span><br><span class="line">			list-style: none;</span><br><span class="line">		&#125;</span><br><span class="line">		li:nth-of-type(2n) &#123;</span><br><span class="line">			background-color : red; </span><br><span class="line">		&#125;</span><br><span class="line">		li:nth-of-type(2n + 1) &#123;</span><br><span class="line">			background-color : green; </span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">		&lt;li&gt;first&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;second&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;third&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;forth&lt;/li&gt;</span><br><span class="line">	&lt;/ul&gt;</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">	        function test() &#123;</span><br><span class="line">				var liCollection = document.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">				for(var i = 0; i &lt; liCollection.length; i++) &#123;</span><br><span class="line">					(function (j) &#123;</span><br><span class="line">						liCollection[j].onclick = function() &#123;</span><br><span class="line">							console.log(j);</span><br><span class="line">						&#125;</span><br><span class="line">						</span><br><span class="line">					&#125;(i))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		test();</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-5-扩展"><a href="#2-3-5-扩展" class="headerlink" title="2.3.5 扩展"></a>2.3.5 扩展</h3><p>写一个方法，求一个字符串的字节长度。（提示：字符串有一个方法charCodeAt() ，一个中文占两个字节，一个英文占一个字节）</p>
<p>定义和方法</p>
<p>charCodeAt()方法可返回指定位置字符的Unicode编码，这个返回值是0~65535之间的整数。（当返回值 &lt;&#x3D; 255时，为英文，当返回值 &gt; 255时为中文）</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.charCodeAt(index)</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var str = &quot;Hello, World!&quot;;</span><br><span class="line">    document.write(str.charCodeAt(1));	//输出101</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getBytesLen(str) &#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    for(var i = 0; i &lt; str.length; i ++) &#123;</span><br><span class="line">    	if(str.charCodeAt(i) &lt;= 255) &#123;</span><br><span class="line">    		count ++;</span><br><span class="line">    	&#125; else if(str.charCodeAt(i) &gt; 255) &#123;</span><br><span class="line">    		count += 2;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(count);</span><br><span class="line">&#125;</span><br><span class="line">getBytesLen(&quot;Hello, World!我爱矿大&quot;);</span><br></pre></td></tr></table></figure>

<p>简化代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getBytesLen(str) &#123;</span><br><span class="line">    var len = str.length;</span><br><span class="line">    var count = len;</span><br><span class="line">    for(var i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">    	if(str.charCodeAt(i) &gt; 255) &#123;</span><br><span class="line">    		count ++;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(count);</span><br><span class="line">&#125;</span><br><span class="line">getBytesLen(&quot;Hello, World!我爱矿大&quot;);</span><br></pre></td></tr></table></figure>

<p>结果如下图</p>
<p><img src="https://img-blog.csdnimg.cn/20190922154741280.png"></p>
<p>微店前端面试题</p>
<p>写出下面程序的执行结果（此题考查逗号运算符的结果，结果返回最后一个逗号后面的表达式的值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = (</span><br><span class="line">    function f() &#123;</span><br><span class="line">    	return &quot;1&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">    function g() &#123;</span><br><span class="line">    	return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    ());</span><br><span class="line">console.log(typeof f);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190922165932957.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">    if(function f() &#123;&#125;) &#123;</span><br><span class="line">    	x += typeof f;</span><br><span class="line">    &#125;</span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190922171918855.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/12/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/" data-id="cl1qb1dy30030qktu1znmg475" data-title="JavaScript学习记录1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript函数与作用域" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/11/JavaScript%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T13:26:48.000Z" itemprop="datePublished">2019-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/11/JavaScript%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/">JavaScript函数与作用域</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript函数与作用域"><a href="#JavaScript函数与作用域" class="headerlink" title="JavaScript函数与作用域"></a>JavaScript函数与作用域</h1><h2 id="1-函数特点"><a href="#1-函数特点" class="headerlink" title="1 函数特点"></a>1 函数特点</h2><p>高内聚，低耦合</p>
<h2 id="2-基本格式与命名规范"><a href="#2-基本格式与命名规范" class="headerlink" title="2 基本格式与命名规范"></a>2 基本格式与命名规范</h2><h3 id="2-1-函数名首字母小写，后面的首字母均大写"><a href="#2-1-函数名首字母小写，后面的首字母均大写" class="headerlink" title="2.1 函数名首字母小写，后面的首字母均大写"></a>2.1 函数名首字母小写，后面的首字母均大写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function printHelloWorld(a) &#123;</span><br><span class="line">    document.write(&quot;Hello, World!&quot;);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-三种函数定义方式"><a href="#2-2-三种函数定义方式" class="headerlink" title="2.2 三种函数定义方式"></a>2.2 三种函数定义方式</h3><p>直接定义函数表达式<br>function printHelloWorld() {<br>    document.write(“Hello, World!”);<br>}<br>调用方式 printHelloWorld()；</p>
<p>命名函数表达式<br>unction test &#x3D; printHelloWorld() {<br>    document.write(“Hello, World!”);<br>}<br>调用方式 test()；</p>
<p>匿名函数表达式<br>function test &#x3D; () {<br>    document.write(“Hello, World!”);<br>}<br>调用方式 test()；</p>
<h2 id="3-参数"><a href="#3-参数" class="headerlink" title="3 参数"></a>3 参数</h2><h3 id="3-1-形参与实参"><a href="#3-1-形参与实参" class="headerlink" title="3.1 形参与实参"></a>3.1 形参与实参</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">    var c = a + b;</span><br><span class="line">    document.write(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参和实参数目可以不同，但会有一个数组arguments[] 存储实参列表，并且与最初传入的实参相对应</p>
<ul>
<li>形参 &gt; 实参<br>未给值形参为 undefined，arguments[]中只含有实参个数的参数，在函数体中改变多余的形参，arguments[]中的对应位置参数不变</li>
<li>实参 &gt; 形参<br>后面实参舍弃，arguments[]中只含有实参个数的参数，在函数体中改变形参，arguments[]中的对应位置参数也变</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, c) &#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3, 4);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190918214223679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<p>形参和实参的利用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, c, d) &#123;</span><br><span class="line">    if(add.length &gt; arguments.length) &#123;</span><br><span class="line">   	   	console.log(&quot;形参多了&quot;);</span><br><span class="line">    &#125; else if(add.length &lt; arguments.length) &#123;</span><br><span class="line">    	console.log(&quot;实参多了&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	console.log(&quot;形参和实参数目相等&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">add(1, null, undefined, &quot;acb&quot;);</span><br></pre></td></tr></table></figure>

<p>不定参数个数求多个数字相加的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(a) &#123;</span><br><span class="line">    var result = 0;</span><br><span class="line">    for(var tmp = 0; tmp &lt; arguments.length; tmp++) &#123;</span><br><span class="line">    	result += arguments[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3, 4);</span><br></pre></td></tr></table></figure>

<p>将输入的数字逆序并输出对应的汉字形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function reverse() &#123;</span><br><span class="line">    var num = window.prompt(&quot;Please input the number：&quot;);</span><br><span class="line">    var str = &quot;&quot;;</span><br><span class="line">    for(var i = num.length - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">    	str += transfer(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    document.write(str);</span><br><span class="line">&#125;</span><br><span class="line">function transfer(target) &#123;</span><br><span class="line">    switch(target) &#123;</span><br><span class="line">    	case &quot;1&quot; :</span><br><span class="line">    		return &quot;壹&quot;;</span><br><span class="line">    	case &quot;2&quot; :</span><br><span class="line">    		return &quot;贰&quot;;</span><br><span class="line">    	case &quot;3&quot; :</span><br><span class="line">    		return &quot;叁&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">reverse();</span><br></pre></td></tr></table></figure>

<h2 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4 作用域"></a>4 作用域</h2><p>全局变量，局部变量</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/11/JavaScript%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/" data-id="cl1qb1dxy002pqktueu9ze867" data-title="JavaScript函数与作用域" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CUMTOJ算法实验一" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/11/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%B8%80/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T13:22:49.000Z" itemprop="datePublished">2019-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/11/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%B8%80/">CUMTOJ算法实验一</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="问题-A-判断字符串是否是手机号码"><a href="#问题-A-判断字符串是否是手机号码" class="headerlink" title="问题 A: 判断字符串是否是手机号码"></a>问题 A: 判断字符串是否是手机号码</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>手机号码是一串数字，长度为11位，并且第一位必须是1，现在给出一个字符串，我们需要判断这个字符串是否符合手机格式。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>多组测试数据。每组数据输入一个字符串。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>若该字符串符合手机号码格式，输出1，否则输出0。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>12345612345</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可封装在一个返回 bool 的 Judge() 函数中，考虑三个方面：</p>
<ol>
<li>是不是 11 位；</li>
<li>首位是不是为 “1”；</li>
<li>每位是不是数字。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int num = 1000;</span><br><span class="line">bool Judge(char str[]);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char str[num];</span><br><span class="line">    while(cin &gt;&gt; str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(Judge(str))</span><br><span class="line">        	cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">    		cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">bool Judge(char str[])</span><br><span class="line">&#123;</span><br><span class="line">    if(strlen(str) != 11 || str[0] != &#x27;1&#x27;) </span><br><span class="line">   		return false;</span><br><span class="line">    for(int i = 0; i &lt; 11; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str[i] &lt; &#x27;0&#x27; || str[i] &gt; &#x27;9&#x27;)</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-B-内部收益率"><a href="#问题-B-内部收益率" class="headerlink" title="问题 B: 内部收益率"></a>问题 B: 内部收益率</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://img-blog.csdnimg.cn/2019091616183984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p><img src="https://img-blog.csdnimg.cn/20190916161847408.png"></p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>1<br>-1 2<br>2<br>-8 6 9<br>0</p>
</blockquote>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1.00<br>0.50</p>
</blockquote>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>题目两边等式同乘 (1+IRR)T。则原题相当于求：CF0(1+IRR)T+CF1(1+IRR)T−1+⋯+CFT&#x3D;0 的解，则可使用二分法。<br>L 初始值取 -1.0，R 初始值取常规正无穷大（我这里取100000）。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int inf_num = 100000;</span><br><span class="line">const double eps = 1e-6;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    double cf[13] , l , r , m;</span><br><span class="line">    while(cin &gt;&gt; T &amp;&amp; T)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 0; i &lt;= T; i++)</span><br><span class="line">            cin &gt;&gt; cf[i];</span><br><span class="line">        l = -1.00;</span><br><span class="line">        r = inf_num;</span><br><span class="line">        while(r - l &gt; eps)</span><br><span class="line">        &#123;</span><br><span class="line">            m = (l + r) / 2;</span><br><span class="line">            double sum = 0.0;</span><br><span class="line">            for(int i = 0; i &lt;= T; i++)</span><br><span class="line">                sum += cf[i] * pow(1 + m , T - i);</span><br><span class="line">            if(sum &gt; 0)</span><br><span class="line">				l = m;</span><br><span class="line">            else</span><br><span class="line">  				r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-C-跳台阶"><a href="#问题-C-跳台阶" class="headerlink" title="问题 C: 跳台阶"></a>问题 C: 跳台阶</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例。每组测试样例包含一个整数n。(1&lt;&#x3D;n&lt;&#x3D;100)</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量.</p>
<p>所得到的结果模1000000007</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>3<br> 4</p>
</blockquote>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>3<br>5</p>
</blockquote>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>假设青蛙在第 n 级台阶，那么我们倒推一步，故易得青蛙跳台阶的问题就是斐波那契数列的问题<br>此题有时间限制，故用空间换时间，用一个数组存储结果<br>因为它每次可以跳 1 级台阶或者 2 级台阶，所以它上一步只能在第 n-1 级或者第 n-2 级台阶，每次都要对 1e9 + 7 取余所以可写出递推式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fib_seq[n] = (Fib_seq[n-1] + Fib_seq[n-2]) % mod;</span><br></pre></td></tr></table></figure>

<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">const int arr_len = 101;</span><br><span class="line">ll Fib_seq[arr_len] = &#123;1, 1&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int step_num;</span><br><span class="line">	for(int i = 2; i &lt; arr_len; i++)</span><br><span class="line">        Fib_seq[i] = (Fib_seq[i - 1] + Fib_seq[i - 2]) % mod;</span><br><span class="line">	while(cin &gt;&gt; step_num)</span><br><span class="line">		cout &lt;&lt; Fib_seq[step_num] &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-D-奶牛的聚会"><a href="#问题-D-奶牛的聚会" class="headerlink" title="问题 D: 奶牛的聚会"></a>问题 D: 奶牛的聚会</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://img-blog.csdnimg.cn/20190916170220473.png"></p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p><img src="https://img-blog.csdnimg.cn/20190916170239769.png"></p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出 “Case #c: ans” ，其中c表示测试数据编号，ans表示消极情绪之和的最小值，结果四舍五入为一个整数。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>1<br>5<br>0.9 2<br>1.4 4<br>3.1 1<br>6.2 1<br>8.3 2</p>
</blockquote>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>Case #1: 300</p>
</blockquote>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><h3 id="函数的凹凸性"><a href="#函数的凹凸性" class="headerlink" title="函数的凹凸性"></a>函数的凹凸性</h3><ol>
<li>设函数f(x)在区间[a,b]上连续，(a,b)内可导，<br>如果在区间(a,b)上f(x)的一阶导数单调递增，那么f(x)在[a,b]上是凹的。<br>如果在区间(a,b)上f(x)的一阶导数单调递减，那么f(x)在[a,b]上是凸的。</li>
<li>设函数f(x)在区间[a,b]上连续，(a,b)内二阶可导，<br>如果在区间(a,b)上f(x)的二阶导数&gt;0，那么f(x)在[a,b]上是凸函数（图像为凹的）<br>如果在区间(a,b)上f(x)的二阶导数&lt;0，那么f(x)在[a,b]上是凹函数（图像为凸的）</li>
</ol>
<h3 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h3><ol>
<li>三分法主要用于求解一个函数在某个区间内的极大（极小）值点，类似于二分法做一个比较：</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>二分法</th>
<th>三分法</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>求解一个函数的零点</td>
<td>求解一个函数的极大（极小）值点</td>
</tr>
<tr>
<td>条件</td>
<td>函数在这个区间是单调函数</td>
<td>函数在这个区间是凸（凹）函数</td>
</tr>
</tbody></table>
<p>对于一个凹函数y&#x3D;f(x)，我们要求它的极小值点。</p>
<p>首先确定它的极小值点所在的区间为[l,r]</p>
<p>计算出两个三分点：</p>
<p>mid&#x3D;(l+r)&#x2F;2</p>
<p>mid2&#x3D;(mid+r)&#x2F;2</p>
<p>（其实这两个点的位置是灵活的）</p>
<p>此时 l &lt; mid &lt; mid2 &lt; r</p>
<p>计算出对应的函数值 f(mid)和f(mid2)。</p>
<p>当f(mid) &lt; f(mid2)时，则极小值点一定不会在mid2和r之间。</p>
<p>反之f(mid) &gt; f(mid2)时，极小值点一定该不会在l和mid之间。</p>
<p>因此，当f(mid) &lt; f(mid2)时，极小值点在[l,mid2]内。此时令l&#x3D;l，r&#x3D;mid2继续计算。</p>
<p>当f(mid)&gt;f(mid2)时，极小值点在[mid,r]内。此时令l&#x3D;mid，r&#x3D;r继续计算。</p>
<p>直到这个区间足够小，可以认为l&#x3D;r时，l就是所求的极小值点。（可接受的误差内）</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">double x[50005][2];</span><br><span class="line">int n;</span><br><span class="line">double cal(double xx)</span><br><span class="line">&#123;</span><br><span class="line">    double sum = 0;</span><br><span class="line">    for(int i = 0; i &lt; n; i++)</span><br><span class="line">        sum += fabs(x[i][0] - xx) * fabs(x[i][0] - xx) * fabs(x[i][0] - xx) * x[i][1];</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    for(int w = 1; w &lt;= t; w++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; x[i][0] &gt;&gt; x[i][1];</span><br><span class="line">        double L = -1000000 , r = 1000000;</span><br><span class="line">        while(L + 0.00001 &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            double Lmid = L + (r - L) / 3;</span><br><span class="line">            double rmid = r - (r - L) / 3;</span><br><span class="line">            if(cal(Lmid) &lt; cal(rmid))</span><br><span class="line">				r = rmid;</span><br><span class="line">            else</span><br><span class="line">				L = Lmid;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; w &lt;&lt; &quot;: &quot; &lt;&lt; (ll)(cal(L) + 0.5) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题-E-光合作用"><a href="#问题-E-光合作用" class="headerlink" title="问题 E: 光合作用"></a>问题 E: 光合作用</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>蒜头是个爱学习的孩子，他总喜欢在生活中做一些小实验，这次蒜头想研究一下光合作用。蒜头的实验材料有如下几样：神奇的种子，普通的纸箱和一些光源。一开始，蒜头将种子均匀的种在了箱子底部，你可以将其看成 X 轴，种子的位置为 X 轴上的点。然后蒜头用纸板将箱子盖住，并在纸板上安装了一些光源（具体见图，顶上的为光源，光源两边与顶部的夹角都为45度，黄色部分为光照，绿色的为植物。）。神奇的种子会在有光的情况下一直向上生长直到没光为止。现在蒜头想知道当实验结束时每颗种子的高度是多少？</p>
<p><img src="https://img-blog.csdnimg.cn/20190916191339202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTA5MjAw,size_16,color_FFFFFF,t_70"></p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>第一行输入一个整数 T，表示测试数据的组数。</p>
<p>每组数据的第一行是三个整数 n,m,h(1&lt;&#x3D;n,m&lt;&#x3D;1e5,0&lt;&#x3D;m&lt;&#x3D;1e5,1&lt;&#x3D;h&lt;&#x3D;1e4),n表示种子数(编号为1,2…n)，m表示光源数,h 表示箱子的高度。</p>
<p>接下来m行，每行一个整数Xi表示第i个光源在顶部的位置。</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，请输出n行，每行一个数表示第i颗种子的最终高度。</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>2<br>7 1 2<br>4<br>4 4 1<br>1<br>2<br>3<br>4</p>
</blockquote>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>0<br>0<br>1<br>2<br>1<br>0<br>0<br>1<br>1<br>1<br>1</p>
</blockquote>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>二分找到当前位置的前后。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int max_num = 1e5 + 5;</span><br><span class="line">int arr[max_num];</span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        int n , m , h;</span><br><span class="line">       cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;</span><br><span class="line">        for(int i = 1; i &lt;= m; i++)</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        sort(arr + 1 , arr + m + 1);</span><br><span class="line">        for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int ans = 0;</span><br><span class="line">            int cnt = lower_bound(arr + 1 , arr + m + 1 , i) - arr;</span><br><span class="line">            if(cnt == 1 &amp;&amp; m != 0)</span><br><span class="line">                ans = max(ans , h - arr[cnt] + i);</span><br><span class="line">            else if(cnt == m + 1 &amp;&amp; m != 0)</span><br><span class="line">                ans = max(ans , h - i + arr[cnt - 1]);</span><br><span class="line">            else if(m != 0)</span><br><span class="line">                ans = max(0 , max(h - i + arr[cnt - 1] , h - arr[cnt] + i));</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本文参考了如下大佬们的文章</p>
<p><a target="_blank" rel="noopener" href="https://comydream.github.io/2018/09/28/algorithm-experiment-1/">https://comydream.github.io/2018/09/28/algorithm-experiment-1/</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yfr2zaz/p/11083207.html">https://www.cnblogs.com/yfr2zaz/p/11083207.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/syiml/p/3675214.html">https://www.cnblogs.com/syiml/p/3675214.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/littlepear/p/6033783.html">https://www.cnblogs.com/littlepear/p/6033783.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/11/CUMTOJ%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E4%B8%80/" data-id="cl1qb1dxi001oqktu892ahapf" data-title="CUMTOJ算法实验一" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript学习记录2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/11/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T13:20:36.000Z" itemprop="datePublished">2019-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/11/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/">JavaScript学习记录2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>最近在学习JavaScript，今天学到了下面的内容，做个回顾吧。</p>
<h1 id="2-学习内容"><a href="#2-学习内容" class="headerlink" title="2 学习内容"></a>2 学习内容</h1><h2 id="2-1-switch-case语句的使用"><a href="#2-1-switch-case语句的使用" class="headerlink" title="2.1 switch case语句的使用"></a>2.1 switch case语句的使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">		var date = window.prompt(&quot;请输入你要比较转换的值：&quot;);</span><br><span class="line">		switch(date) &#123;</span><br><span class="line">			case &quot;Monday&quot; :</span><br><span class="line">				document.write(&quot;It is Monday.&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &quot;Tuesday&quot; :</span><br><span class="line">				document.write(&quot;It is Tuesday.&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &quot;Wednesday&quot; :</span><br><span class="line">				document.write(&quot;It is Wednesday.&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &quot;Thursday&quot; :</span><br><span class="line">				document.write(&quot;It is Thursday.&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &quot;Friday&quot; :</span><br><span class="line">				document.write(&quot;It is Friday.&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &quot;Saturday&quot; :</span><br><span class="line">				document.write(&quot;It is Saturday.&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &quot;Sunday&quot; :</span><br><span class="line">				document.write(&quot;It is Sunday.&quot;);</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>注释：</p>
<ul>
<li>console.log(“在控制台中打印输出”)</li>
<li>document.write(“在网页中打印输出”)</li>
</ul>
<h2 id="2-2、for，while循环的使用"><a href="#2-2、for，while循环的使用" class="headerlink" title="2.2、for，while循环的使用"></a>2.2、for，while循环的使用</h2><p>把从1到100中含有7和7的倍数的数字去除</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">		for(var tmp = 0; tmp &lt; 100; tmp++) &#123;</span><br><span class="line">			if(tmp % 7 == 0 || tmp % 10 == 7) &#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			document.write(tmp + &quot;&lt;br&gt;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">		var num = 1;</span><br><span class="line">		while(num &lt; 100) &#123;</span><br><span class="line">			if(num % 7 != 0 &amp;&amp; num % 10 != 7) &#123;</span><br><span class="line">				document.write(num + &quot;&lt;br&gt;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-数组，对象的使用"><a href="#2-3-数组，对象的使用" class="headerlink" title="2.3 数组，对象的使用"></a>2.3 数组，对象的使用</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">		var arr1 = [1 , 2 , 3 , &#x27;ikun&#x27; , undefined];</span><br><span class="line">		var arr2 = [1 , 2 , 3 , 4 , 5];</span><br><span class="line">		document.write(arr1.length);</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>注释：</p>
<ul>
<li>数组中可以是任何类型的数据</li>
<li>arr.length</li>
<li>typeof后返回object</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">		var obj = &#123;</span><br><span class="line">			name : &quot;李嘉诚&quot;,</span><br><span class="line">			birth_data : &quot;1928.7.29&quot;,</span><br><span class="line">			live_place : &quot;香港深水湾&quot;,</span><br><span class="line">			age : 91,</span><br><span class="line">			money : 400,</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>注释：</p>
<ul>
<li>typeof后返回object</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/11/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952/" data-id="cl1qb1dxz002sqktucoqz3rf5" data-title="JavaScript学习记录2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript学习记录3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/11/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T13:20:36.000Z" itemprop="datePublished">2019-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/11/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/">JavaScript学习记录3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>最近在学习JavaScript，今天学到了下面的内容，做个回顾吧。</p>
<p>JavaScript的数据类型及强弱类型</p>
<h2 id="2-1-JS数据类型"><a href="#2-1-JS数据类型" class="headerlink" title="2.1 JS数据类型"></a>2.1 JS数据类型</h2><p>JavaScript中有6种数据类型：数字（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（Object）。其中对象类型包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date）。</p>
<h2 id="2-2-JS数据类型的判断"><a href="#2-2-JS数据类型的判断" class="headerlink" title="2.2 JS数据类型的判断"></a>2.2 JS数据类型的判断</h2><p>利用函数typeof()进行判断，可以返回六种<code>字符串类型</code>的值<br>数字（number）、字符串（string）、布尔值（boolean）、函数（Function）、对象（Object）、undefined<br>示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.write(typeof(1) + &quot;&lt;br&gt;&quot;);</span><br><span class="line">document.write(typeof &#x27; &#x27; + &quot;&lt;br&gt;&quot;);</span><br><span class="line">document.write(typeof true + &quot;&lt;br&gt;&quot;);</span><br><span class="line">document.write(typeof undefined + &quot;&lt;br&gt;&quot;);</span><br><span class="line">document.write(typeof null + &quot;&lt;br&gt;&quot;);</span><br><span class="line">document.write(typeof new Function() + &quot;&lt;br&gt;&quot;);</span><br><span class="line">document.write(typeof [] + &quot;&lt;br&gt;&quot;);</span><br><span class="line">document.write(document.write(typeof new Date() + &quot;&lt;br&gt;&quot;));</span><br><span class="line">document.write(typeof new RegExp() + &quot;&lt;br&gt;&quot;);</span><br></pre></td></tr></table></figure>

<p>输出结果如下所示</p>
<p><img src="https://img-blog.csdnimg.cn/20190918164656687.png"></p>
<p>注释</p>
<ol>
<li>数组返回object</li>
<li>null返回object</li>
<li>typeof后返回object</li>
</ol>
<h3 id="2-2-1-强类型定义语言："><a href="#2-2-1-强类型定义语言：" class="headerlink" title="2.2.1 强类型定义语言："></a>2.2.1 强类型定义语言：</h3><p>强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。</p>
<h3 id="2-2-2-弱类型定义语言："><a href="#2-2-2-弱类型定义语言：" class="headerlink" title="2.2.2 弱类型定义语言："></a>2.2.2 弱类型定义语言：</h3><p>数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。<br>强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！</p>
<h2 id="2-3-类型转换"><a href="#2-3-类型转换" class="headerlink" title="2.3 类型转换"></a>2.3 类型转换</h2><h3 id="2-3-1-显式类型转换"><a href="#2-3-1-显式类型转换" class="headerlink" title="2.3.1 显式类型转换"></a>2.3.1 显式类型转换</h3><h4 id="2-3-1-1-Number-mix"><a href="#2-3-1-1-Number-mix" class="headerlink" title="2.3.1.1 Number(mix)"></a>2.3.1.1 Number(mix)</h4><p>示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var num = Number(&quot;123&quot;);</span><br><span class="line">    var demo_true = Number(true);</span><br><span class="line">    var demo_false = Number(false);</span><br><span class="line">    var KONG = Number(null);</span><br><span class="line">    var weidingyi = Number(undefined);</span><br><span class="line">    var zimu = Number(&quot;a&quot;);</span><br><span class="line">    var zimu_shuzi = Number(&quot;123abc&quot;);</span><br><span class="line">    document.write(typeof(num) + &quot; : &quot; + num + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    document.write(typeof(demo_true) + &quot; : &quot; + demo_true + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    document.write(typeof(demo_false) + &quot; : &quot; + demo_false + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    document.write(typeof(KONG) + &quot; : &quot; + KONG + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    document.write(typeof(weidingyi) + &quot; : &quot; + weidingyi + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    document.write(typeof(zimu) + &quot; : &quot; + zimu + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    document.write(typeof(zimu_shuzi) + &quot; : &quot; + zimu_shuzi + &quot;&lt;br&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="https://img-blog.csdnimg.cn/20190918174934267.png"></p>
<h4 id="2-3-1-2-parseInt-string-radix"><a href="#2-3-1-2-parseInt-string-radix" class="headerlink" title="2.3.1.2 parseInt(string,radix)"></a>2.3.1.2 parseInt(string,radix)</h4><p>2.3.1.2.1 将待转换的纯字符串数字和数字去掉小数点后面的部分并取其整数部分，其他值均返回NaN</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var num = parseInt(&quot;123&quot;);</span><br><span class="line">    var zifu = parseInt(&quot;abs&quot;);</span><br><span class="line">    var qita = parseInt(undefined);</span><br><span class="line">    var kong = parseInt(null);</span><br><span class="line">    document.write(typeof(num) + &quot; : &quot; + num + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    document.write(typeof(zifu) + &quot; : &quot; + zifu + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    document.write(typeof(qita) + &quot; : &quot; + qita + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    document.write(typeof(kong) + &quot; : &quot; + kong + &quot;&lt;br&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>转换结果<br><img src="https://img-blog.csdnimg.cn/20190918175527631.png"></p>
<p>2.3.1.2.2 将待转数字从其他进制转成十进制</p>
<p>16那个位置的radix取值范围2~36</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var num = parseInt(&quot;10&quot; , 16);</span><br><span class="line">    document.write(typeof(num) + &quot; : &quot; + num + &quot;&lt;br&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190918180001485.png"></p>
<p>2.3.1.2.3 取出数字加字母中的整数数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	var num = parseInt(&quot;123.4abc&quot;);</span><br><span class="line">	var photo = parseInt(&quot;567px&quot;);</span><br><span class="line">	document.write(typeof(num) + &quot; : &quot; + num + &quot;&lt;br&gt;&quot;);</span><br><span class="line">	document.write(typeof(photo) + &quot; : &quot; + photo + &quot;&lt;br&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190918180237486.png"></p>
<h4 id="3-1-3-parseFloat-string"><a href="#3-1-3-parseFloat-string" class="headerlink" title="3.1.3 parseFloat(string)"></a>3.1.3 parseFloat(string)</h4><p>取出数字加字母中的小数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	var num = parseFloat(&quot;123.4.5abc&quot;);</span><br><span class="line">	document.write(typeof(num) + &quot; : &quot; + num + &quot;&lt;br&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190918180532240.png"></p>
<h4 id="2-3-1-4-String-mix"><a href="#2-3-1-4-String-mix" class="headerlink" title="2.3.1.4 String(mix)"></a>2.3.1.4 String(mix)</h4><p>不管mix中时什么数据，将mix转换成字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	var param1 = String(&quot;123.4.5abc&quot;);</span><br><span class="line">	var param2 = String(null);</span><br><span class="line">	var param3 = String(undefined);</span><br><span class="line">	document.write(typeof(param1) + &quot; : &quot; + param1 + &quot;&lt;br&gt;&quot;);</span><br><span class="line">	document.write(typeof(param2) + &quot; : &quot; + param2 + &quot;&lt;br&gt;&quot;);</span><br><span class="line">	document.write(typeof(param3) + &quot; : &quot; + param3 + &quot;&lt;br&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190918180904120.png"></p>
<h4 id="2-3-1-5-Boolean-mix"><a href="#2-3-1-5-Boolean-mix" class="headerlink" title="2.3.1.5 Boolean(mix)"></a>2.3.1.5 Boolean(mix)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	var param1 = Boolean(&quot;123.4.5abc&quot;);</span><br><span class="line">	var param2 = Boolean(null);</span><br><span class="line">	var param3 = Boolean(undefined);</span><br><span class="line">	var param4 = Boolean(&#x27;&#x27;);</span><br><span class="line">	document.write(typeof(param1) + &quot; : &quot; + param1 + &quot;&lt;br&gt;&quot;);</span><br><span class="line">	document.write(typeof(param2) + &quot; : &quot; + param2 + &quot;&lt;br&gt;&quot;);</span><br><span class="line">	document.write(typeof(param3) + &quot; : &quot; + param3 + &quot;&lt;br&gt;&quot;);</span><br><span class="line">	document.write(typeof(param4) + &quot; : &quot; + param4 + &quot;&lt;br&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190918181152278.png"></p>
<h4 id="2-3-1-6-toString-radix"><a href="#2-3-1-6-toString-radix" class="headerlink" title="2.3.1.6 toString(radix)"></a>2.3.1.6 toString(radix)</h4><ol>
<li>null和undefined没有toString()属性</li>
<li>将数字转换成对应进制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var num1 = 10;</span><br><span class="line">    var test1 = num1.toString(8);</span><br><span class="line">    document.write(typeof(test1) + &quot; : &quot; + test1 + &quot;&lt;br&gt;&quot;);</span><br><span class="line">    var num2 = 1010;</span><br><span class="line">    var test2 = parseInt(num2 , 2);</span><br><span class="line">    var param2 = test2.toString(16);</span><br><span class="line">    document.write(typeof(param2) + &quot; : &quot; + param2 + &quot;&lt;br&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190918182325651.png"></p>
<h3 id="2-3-2-隐式类型转换"><a href="#2-3-2-隐式类型转换" class="headerlink" title="2.3.2 隐式类型转换"></a>2.3.2 隐式类型转换</h3><h4 id="2-3-2-1-isNaN-param"><a href="#2-3-2-1-isNaN-param" class="headerlink" title="2.3.2.1 isNaN(param)"></a>2.3.2.1 isNaN(param)</h4><p>Number(param) &lt; – &gt; NaN</p>
<p>将param用Number()转换，然后与NaN比对</p>
<h4 id="2-3-2-2-param-和param–"><a href="#2-3-2-2-param-和param–" class="headerlink" title="2.3.2.2 param++和param–"></a>2.3.2.2 param++和param–</h4><p>将param用Number()转换，然后再加（减）1，但即使转不成数字，typeof之后仍是数字类型</p>
<h4 id="2-3-2-3-param和-param（一元正负）"><a href="#2-3-2-3-param和-param（一元正负）" class="headerlink" title="2.3.2.3 + param和- param（一元正负）"></a>2.3.2.3 + param和- param（一元正负）</h4><p>将param用Number()转换，但即使转不成数字，typeof之后仍是数字类型</p>
<h4 id="2-3-2-4-a-b"><a href="#2-3-2-4-a-b" class="headerlink" title="2.3.2.4 a + b"></a>2.3.2.4 a + b</h4><p>+两侧又一个字符串，所得结果即为字符串</p>
<h4 id="2-3-2-5-x2F"><a href="#2-3-2-5-x2F" class="headerlink" title="2.3.2.5 - * &#x2F; %"></a>2.3.2.5 - * &#x2F; %</h4><p>Number()</p>
<h4 id="2-3-2-6-amp-amp"><a href="#2-3-2-6-amp-amp" class="headerlink" title="2.3.2.6 &amp;&amp; || !"></a>2.3.2.6 &amp;&amp; || !</h4><p>Boolean()</p>
<h4 id="2-3-2-7-gt-lt-lt-x3D-gt-x3D"><a href="#2-3-2-7-gt-lt-lt-x3D-gt-x3D" class="headerlink" title="2.3.2.7 &gt; &lt; &lt;&#x3D; &gt;&#x3D;"></a>2.3.2.7 &gt; &lt; &lt;&#x3D; &gt;&#x3D;</h4><p>字符串与数字比，将字符串转换成数字再比较（数字优先）</p>
<h4 id="2-3-2-8-x3D-x3D-x3D-（一样）"><a href="#2-3-2-8-x3D-x3D-x3D-（一样）" class="headerlink" title="2.3.2.8 &#x3D;&#x3D; !&#x3D;（一样）"></a>2.3.2.8 &#x3D;&#x3D; !&#x3D;（一样）</h4><p>1&#x3D;&#x3D;1为true<br>1 &#x3D;&#x3D; “1”为true</p>
<h4 id="2-3-2-9-x3D-x3D-x3D-x3D-x3D-（一样）"><a href="#2-3-2-9-x3D-x3D-x3D-x3D-x3D-（一样）" class="headerlink" title="2.3.2.9 &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;（一样）"></a>2.3.2.9 &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;（一样）</h4><p>其他值均绝对，但NaN&#x3D;&#x3D;&#x3D;NaN为false</p>
<h4 id="2-3-2-10-特殊"><a href="#2-3-2-10-特殊" class="headerlink" title="2.3.2.10 特殊"></a>2.3.2.10 特殊</h4><p>undefined&gt;0为false<br>undefined&lt;0为false<br>undefined &#x3D;&#x3D; 0为false<br>null &gt; 0为false<br>null &lt; 0为false<br>null &#x3D;&#x3D; 0为false<br>null &#x3D;&#x3D; undefined为true<br>NaN&#x3D;&#x3D;NaN为false<br>document.write(typeof(typeof(param2)))返回string</p>
<h4 id="2-3-2-11-num-toFixed-radix"><a href="#2-3-2-11-num-toFixed-radix" class="headerlink" title="2.3.2.11 num.toFixed(radix)"></a>2.3.2.11 num.toFixed(radix)</h4><p>将num转换成radix个小数的数字，并且四舍五入</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/11/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953/" data-id="cl1qb1dy40034qktu0op425rl" data-title="JavaScript学习记录3" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSharp/">CSharp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cpp/">Cpp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DVWA/">DVWA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E9%AA%8C/">经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/">计算机考研复试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APP-Inventor/" rel="tag">APP Inventor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSharp/" rel="tag">CSharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DVWA/" rel="tag">DVWA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Misc/" rel="tag">Misc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reverse/" rel="tag">Reverse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/writeup/" rel="tag">writeup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6/" rel="tag">信息安全数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%93%E4%B8%8E%E6%A8%A1%E5%9D%97/" rel="tag">库与模块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/" rel="tag">拒绝服务攻击</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E6%9D%90%E7%AD%94%E6%A1%88/" rel="tag">教材答案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/" rel="tag">牛客网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E9%AA%8C/" rel="tag">经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" rel="tag">网络安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/" rel="tag">计算机考研复试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/APP-Inventor/" style="font-size: 10.83px;">APP Inventor</a> <a href="/tags/Android/" style="font-size: 13.33px;">Android</a> <a href="/tags/C/" style="font-size: 16.67px;">C</a> <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/CSharp/" style="font-size: 10px;">CSharp</a> <a href="/tags/CTF/" style="font-size: 19.17px;">CTF</a> <a href="/tags/DVWA/" style="font-size: 12.5px;">DVWA</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 14.17px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Misc/" style="font-size: 10px;">Misc</a> <a href="/tags/MySQL/" style="font-size: 10.83px;">MySQL</a> <a href="/tags/Reverse/" style="font-size: 11.67px;">Reverse</a> <a href="/tags/Web/" style="font-size: 17.5px;">Web</a> <a href="/tags/python/" style="font-size: 12.5px;">python</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/writeup/" style="font-size: 18.33px;">writeup</a> <a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6/" style="font-size: 10.83px;">信息安全数学</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 14.17px;">前端</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a> <a href="/tags/%E5%8D%8F%E8%AE%AE/" style="font-size: 10.83px;">协议</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 15.83px;">密码学</a> <a href="/tags/%E5%BA%93%E4%B8%8E%E6%A8%A1%E5%9D%97/" style="font-size: 13.33px;">库与模块</a> <a href="/tags/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/" style="font-size: 10.83px;">拒绝服务攻击</a> <a href="/tags/%E6%95%99%E6%9D%90%E7%AD%94%E6%A1%88/" style="font-size: 10px;">教材答案</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/" style="font-size: 15px;">牛客网</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">算法</a> <a href="/tags/%E7%BB%8F%E9%AA%8C/" style="font-size: 16.67px;">经验</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="font-size: 15.83px;">网络安全</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10.83px;">计算机网络</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/" style="font-size: 15.83px;">计算机考研复试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/21/IDA%20Pro%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90dex%E6%96%87%E4%BB%B6/">IDA Pro静态分析dex文件</a>
          </li>
        
          <li>
            <a href="/2021/09/13/%E7%BC%96%E5%86%99%E5%B9%B6%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%80%E4%B8%AAAndroid%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">编写并分析第一个Android应用程序</a>
          </li>
        
          <li>
            <a href="/2021/09/05/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/">Android四大组件</a>
          </li>
        
          <li>
            <a href="/2021/06/25/%E4%B8%AD%E5%9B%BD%E7%9F%BF%E4%B8%9A%E5%A4%A7%E5%AD%A6%E6%9C%AC%E7%A7%91%E7%94%9F%E6%B6%AF%E6%80%BB%E7%BB%93/">中国矿业大学本科生涯总结</a>
          </li>
        
          <li>
            <a href="/2021/03/19/%E5%8C%97%E4%BA%AC%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6%E8%80%83%E7%A0%94--%E5%A4%8D%E8%AF%95--%E6%9C%BA%E8%AF%95%E5%88%B7%E9%A2%98/">北京工业大学考研--复试--机试刷题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 iHui<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>